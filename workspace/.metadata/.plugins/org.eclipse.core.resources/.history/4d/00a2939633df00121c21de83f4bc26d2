/**
 * TODO Questions:
 *  FROM ASSIGNMENT - Flags: Do not support the RST flag, clear it on all outgoing packets.
 *  	Me: Possibly add this? Short bit extra, but seems unnecassary to check for
 *  FROM ASSIGNMENT - Window Management: You must retransmit the packet and wait for the acknowledgment again (with a maximum of ten times).
 *  	Me: Thus, NUM_RETRANSMISSION should be 10 ;)
 *  		ALREADY DONE!
 *  FROM ASSIGNMENT - Window Management: Since you are to implement the stop�n�go protocol, ignore the window size, set it to the maximum size of one packet on all outgoing packets.
 *  	Me: Maybe set the window to 8kb and not 0. May cause problems during reference testing
 *   		Additionally, we can thus assume a fixed size, hence in reading no loop over Arraycopy imho ;)
 *  FROM ASSIGNMENT - TCP Interface: Your Socket class implementation must support no public constructor (it can only be instantiated by a TCP instance),...
 *  	Me: Hence, setting everything to public is inherently incorrect. Would it be a problem if they were set to private within the Socket class?
 *  		This (imho) thus also hold for the method 'pass_over_data()'
 *  		ALREADY DONE!
 *  FROM ME: Yesterday we were discussing the part of resending data right?
 *  		I just noticed I made two variables in the TCB called 'int data_left' and 'packtet_data', respectively (probably)
 *  		 needed for storing the data to send (instead of giving it to send_data as a parameter) and setting the data which wasn't send yet
 *  	Me: ALREADY DONE!
 *  FROM Me: Tip, look at section 2.3 in the assignment.
 *  			It will probably give you some pointers in creating test programs ;)
 *  FROM ME: Discussion, maybe the ack/seq nums are incorrect, since the sequence number and expected acknowledgment numbers are set with
 *  			the 'bytesSend' variable. Could this also contain the IP header and such? Thus, creating an incorrect data length leading to an incorrect sequence number?
 *  		Another point were this could fail, is that the src_seqnum is only changed when an ack comes in (incremented at the end of recv_ack)
 *  		Hence, on synack, the src_seqnum will not be changed, whilst the sender of synack does expect this.
 *  			That is probably why incorrect numbers exist AND is the reason why I ask if recv_ack could always be ran although the flag if could be incorrect
 *  		Is there a possibility to change the flag if at the start of recv_ack, so that it will always proceed in case an ack, synack or finack is received?
 *  	ME: ALREADY DONE! Seq/Acknums work correctly!
 *  FROM RFC793 - Page 53 LISTEN STATE: Should we be able to call the 'connect()' method when 'accept()' was first called.
 *  							Thus, should we be able to move from passive to active, as the RFC specifies?
 *  FROME ME - Global: Hi Gerben,
 *  		In the Socket class I've added the several error message which should be send in case of several states.
 *  		It is conform the implementation given by the RFC793. Hope it still works!
 *  FROM ME - Close: May send one ACK packet to many in case of simultaneous closing.
 *  		This is when the state CLOSING is reached. From receiving a FIN packet, an ACK will already be send. 
 *  		Afterwards, it will reach the part in close() where it has the state CLOSING, where it'll send another ACK
 *  		Maybe redundant, but do not remove unless causes errors
 *  FROM ME - Write: Should a data packet have a minimum size of 1?
 *  FROM ME - Read: Maybe we need to remove the tcpheader ourselves
 */

package nl.vu.cs.cn;

import java.io.IOException;
import java.nio.ByteBuffer;
import java.nio.ByteOrder;
import java.util.Random;

import nl.vu.cs.cn.IP.IpAddress;
import nl.vu.cs.cn.IP.Packet;

/**
 * @author Steven van Beelen, 1821806
 * @coauthor Gerben Rozie
 * 
 * This class represents a TCP stack. It should be built on top of the IP stack
 * 	which is bound to a given IP address.
 */
public class TCP {
	
	public static final byte FIN = 0x01, /** The FIN(finish) byte flag */
	SYN = 0x02, /** The SYN(synchornize) byte flag */
	PSH = 0x08, /** The PSH(push) byte flag */
	ACK = 0x10;
	/** The ACK(acknowledge) byte flag */
	public static final int TIMEOUT = 1, /** Timeout for receiving an acknowledgement in seconds */
	NUM_RETRANSMISSION = 10;
	/** Number of times a send may be resend in case of error */
	
	public IP ip;
	/** The underlying IP stack for this TCP stack. */
	public TCB tcb;
	
	/** The Transmission Control Block for this TCP stack. */
	
	/****************************************************************************************
	 * 								Connecting/Socket Class/Methods 						*
	 ****************************************************************************************/
	
	/**
	 * This class represents a TCP socket.
	 */
	public class Socket {
		
		public static final int DEFAULT_PORT = 12345;
		/** The default port number used for client TCP stacks */
		
		public int port;
		
		/**
		 * Construct a client socket.
		 */
		private Socket() {
			port = DEFAULT_PORT;
		}
		
		/**
		 * Construct a server socket bound to the given local port.
		 *
		 * @param port the local port to use
		 */
		private Socket(int port) {
			this.port = port;
		}
		
		/**
		 * Connect this socket to the specified destination and port.
		 * The client will perform a connect request
		 *
		 * @param dest_ipaddr the destination to connect to
		 * @param port the port to connect to
		 * @return true if the connect succeeded.
		 */
		public boolean connect(IpAddress dest_ipaddr, int port) {
			int bytesSent = 0;
			if (!tcb.state.equals(ConnectionState.CLOSED)) {
				errorMessage(1);
				return false;
			}
			
			tcb.src_port = (short) this.port;
			if (dest_ipaddr == null) {
				System.err.println("Error: foreign address unspecified");
				return false;
			}
			tcb.dest_ipaddr = dest_ipaddr;
			if (port < 0) {
				System.err.println("Error: foreign socket unspecified");
				return false;
			}
			tcb.dest_port = (short) port;
			tcb.src_seqnum = tcb.isseqnum;
			tcb.state = ConnectionState.SYN_SENT;
			System.out.printf("CONNECT:%d Sending syn packet... State: %s\n", tcb.src_port, tcb.state); //TODO Remove print
			bytesSent = send_syn();
			/** 1 step of 3-way-handshake */
			if (bytesSent == -1) {
				tcb.clean();
				return false;
				/** Connecting failed | clean() sets state to CLOSED */
			}
			else if (tcb.state.equals(ConnectionState.ESTABLISHED)) {
				System.out.printf("CONNECT:%d Sending syn packet finished! State: %s\n", tcb.src_port, tcb.state); //TODO Remove print
				System.out.printf("CONNECT:%d Sending ack packet.. State: %s\n", tcb.src_port, tcb.state); //TODO Remove print
				bytesSent = send_ack();
				/** Step 3 of 3-way-handshake (ACK) */
				if (bytesSent == -1) {
					tcb.clean();
					return false;
					/** Connecting failed | clean() sets state to CLOSED */
				}
				System.out.printf("CONNECT:%d Sending ack packet was succesfull State: %s\n", tcb.src_port, tcb.state); //TODO Remove print
			}
			return true;
			/** Connection established */
		}
		
		/**
		 * Accept a connection on this socket.
		 * This call blocks until a connection is made.
		 * The server will wait in the accept method for a connect request
		 */
		public void accept() {
			int bytesSent = 0;
			if (!tcb.state.equals(ConnectionState.CLOSED)) {
				errorMessage(1);
				return;
			}
			
			tcb.src_port = (short) port;
			tcb.state = ConnectionState.LISTEN;
			/** Busy waiting/blocking on receiving a connection request */
			while (!tcb.state.equals(ConnectionState.ESTABLISHED)) {
				System.out.printf("ACCEPT:%d Checking for Connection Request packets\n\tState: %s\n", tcb.src_port, tcb.state); //TODO Remove print
				recv_tcp_packet(true);
				System.out.printf("ACCEPT:%d Possible Connection Request received\n\tState: %s\n", tcb.src_port, tcb.state); //TODO Remove print
				/** Call blocks on receive, be retrying all the time */
				if (tcb.state.equals(ConnectionState.SYN_RCVD)) {
					System.out.printf("ACCEPT:%d A SYN Packet was received!\n\tState: %s\n\tWill send a SYNACK as response\n", tcb.src_port, tcb.state); //TODO Remove print
					tcb.src_seqnum = tcb.isseqnum;
					bytesSent = send_syn();
					System.out.printf("ACCEPT:%d SYN sent\n", tcb.src_port); //TODO Remove print
					/** 2 step of 3-way-handshake (SYNACK) */
					if (bytesSent == -1) {
						System.out.printf("ACCEPT:%d sending SYN packet returned -1 for some reason (see log)\n", tcb.src_port); //TODO Remove print
						tcb.state = ConnectionState.LISTEN;
						continue;
						/** Connecting failed || maybe inappropriate to cancel server in faulty syn sending scenario */
					}
				}
			}
		}
		
		/**
		 * Writes to the socket from the buffer.
		 *
		 * @param buf the buffer to send
		 * @param offset the offset to begin writing data from
		 * @param len the number of bytes to write
		 * @return the number of bytes written or -1 if an error occurs.
		 */
		public int write(byte[] buf, int offset, int len) {
			int dataSize = 0, bytesSent = 0;
			if(buf.length == len){
				tcb.data_left = len;
			}
			else { //Len should equal buf.length, otherwise buffer overflows/underflows could occur
				tcb.data_left = buf.length;
			}
			
			if (!tcb.state.equals(ConnectionState.ESTABLISHED) && !tcb.state.equals(ConnectionState.CLOSE_WAIT)) {
				errorMessage(2);
				return -1;
				/** Not in a state to transmit data */
			}
			
			System.out.printf("WRITE:%d Trying to write data...\n" +
					"\tbufLength: %d offset: %d len: %d tcb.data_left: %d MAX_BUF_SIZE: %d\n", 
					tcb.src_port, buf.length, offset, len, tcb.data_left, TCB.BUF_SIZE);//TODO remove
			/** Looping through the array until all packets have been send */
			while (tcb.data_left > 0) {
				dataSize = Math.min(tcb.data_left, TCB.BUF_SIZE);
				tcb.packet_data = new byte[dataSize];
				System.arraycopy(buf, offset, tcb.packet_data, 0, dataSize);
				/** The actual sending from the socket to the tcp stack */
				System.out.printf("WRITE:%d Buffer copied into tcb.packet_data, now going to SEND_DATA\n" +
						"\tdataSize: %d tcb.packet_data.length: %d\n" +
						"\ttcb.data_left: %d offset: %d\n", 
						tcb.src_port, dataSize, tcb.packet_data.length, tcb.data_left, offset);//TODO remove
				bytesSent = send_data();
				System.out.printf("WRITE:%d send_data returned, with %d bytes sent\n", tcb.src_port, bytesSent);//TODO remove
				if (bytesSent >= 20) { //A data packet should be at least 0 byte large, but first the tcpheader should be removed from the bytes sent
					tcb.data_left -= (bytesSent - 20);
					offset += (bytesSent - 20);
					System.out.printf("WRITE:%d Writing data worked!\n" +
							"\t NEW tcb.data_left: %d NEW offset: %d\n",
							tcb.src_port, tcb.data_left, offset);//TODO remove
				}
				else {
					System.out.printf("WRITE:%d Writing data failed\n", tcb.src_port);//TODO remove
					/** sending data failed | break to check whether failed from the start or only a small piece was send */
					break;
				}
			}
			
			
			if (tcb.data_left == len) {
				System.out.printf("WRITE:%d Writing data failed\n" +
						"\t tcb.data_left(%d) was equal to len(%d), hence nothing was written correcty\n", 
						tcb.src_port, tcb.data_left, len);//TODO remove
				System.err.println("Error: sending data failed");
				return -1;
			}
			System.out.printf("WRITE:%d Writing data finished\n" +
					"\tWrote (len Variable)%d, (buf.length Variable) %d", 
					tcb.src_port, len, buf.length);//TODO remove
			return len - tcb.data_left;
		}
		
		/**
		 * Reads bytes from the socket into the buffer.
		 * This call is not required to return maxlen bytes
		 * every time it returns.
		 *
		 * @param buf the buffer to read into
		 * @param offset the offset to begin reading data into
		 * @param maxlen the maximum number of bytes to read
		 * @return the number of bytes read, or -1 if an error occurs.
		 */
		public int read(byte[] buf, int offset, int maxlen) {
			int bytesRead = 0;
			
			if (!tcb.state.equals(ConnectionState.ESTABLISHED) && !tcb.state.equals(ConnectionState.FIN_WAIT_1) &&
					!tcb.state.equals(ConnectionState.FIN_WAIT_2) && !tcb.state.equals(ConnectionState.CLOSE_WAIT)) {
				errorMessage(3);
				return -1;
				/** If none of these hold, we will not accept data read */
			}
			
			System.out.printf("READ:%d Trying to read data...\n" +
					"\tWill be put in buf with length %d, offset %d and maxlen %d\n", tcb.src_port, buf.length, offset, maxlen);
			bytesRead = recv_tcp_packet(true);
			/** true means waitingReceive, as required by the assignment */
			if (bytesRead == -1) {
				System.out.printf("READ:%d Reading failed...\n", tcb.src_port);
				return -1;
			}
			System.out.printf("READ:%d Reading worked! Going to pass over the data into the buffer\n", tcb.src_port);
			try {
				pass_over_data(buf, offset, maxlen);
			} catch (Exception e) {
				e.printStackTrace();
				System.err.println("Error: moving data to buffer failed");
				return -1;
			}
			System.out.printf("READ:%d Passing over data worked! Sending ACK of data read...\n", tcb.src_port);
			send_ack();
			/** Send acknowledgement for the received data and possibly for received fin */
			System.out.printf("READ:%d Sending ACK finished\n\tReading is done!\n", tcb.src_port);
			
			return bytesRead - 20;
		}
		
		/**
		 * The method copying the received data into the buffer
		 * 
		 * @param buf: the buffer to read into
		 * @param offset: the offset to begin reading data into
		 * @param maxlen: the maximum number of bytes to read
		 */
		private void pass_over_data(byte[] buf, int offset, int maxlen) throws NullPointerException, ArrayStoreException, IndexOutOfBoundsException {
			System.out.printf("PASS_OVER_DATA:%d Going to copy tcb.data in buf array!\n" +
					"\tBufLength: %d Offset: %d MaxLength: %d DataLength: %d\n",
					tcb.src_port, buf.length, offset, maxlen, tcb.data.length);
			byte[] data = tcb.data;
			//System.arraycopy(data, 0, buf, 0, maxlen);
			System.arraycopy(data, 0, buf, offset, data.length);//TODO -20 to remove the tcpheader data
			/** Should write to the buffer at point offset and should read this data from data buffer at the start/zero. Max to read should be the length of the data buffer */
			
			//TODO this probably does the same right ;-) | makes this method rather useless
			
			/*int len = maxlen, dataLeft = data.length, bytesWritten = 0;
			System.out.printf("DATA LEFT: %d\n", dataLeft);
			len = Math.min(maxlen, dataLeft);
			System.out.printf("LEN: %d\n", len);
			System.out.printf("DATA: %s", data);
			System.out.flush();
			System.arraycopy(data, 0, buf, offset, len);
			dataLeft -= len;
			bytesWritten += len;
			offset += len;*/
		}
		
		/**
		 * Closes the connection for this socket.
		 * Blocks until the connection is closed.
		 *
		 * @return true unless no connection was open. 
		 */
		public boolean close() {
			int bytesSent = 0;
			System.out.printf("CLOSE:%d Starting in close method\n", tcb.src_port);
			if (!tcb.state.equals(ConnectionState.LISTEN) && !tcb.state.equals(ConnectionState.SYN_SENT) &&
					!tcb.state.equals(ConnectionState.SYN_RCVD) && !tcb.state.equals(ConnectionState.ESTABLISHED) &&
					!tcb.state.equals(ConnectionState.CLOSE_WAIT)) {
				System.out.printf("CLOSE:%d A-Err\n", tcb.src_port);
				errorMessage(4);
				return false;
				/** Already closed */
			}
			
			if (tcb.state.equals(ConnectionState.LISTEN) || tcb.state.equals(ConnectionState.SYN_SENT)) {
				tcb.clean();
				System.out.printf("CLOSE:%d TCB cleaned up in LISTEN or SYN_SENT state\n", tcb.src_port);//TODO Remove print
			}
			else if (tcb.state.equals(ConnectionState.SYN_RCVD) || tcb.state.equals(ConnectionState.ESTABLISHED)) {
				//CLIENT REQUESTED CLOSE
				System.out.printf("CLOSE:%d Going to send a FIN packet in state %s\n", tcb.src_port, tcb.state);
				ConnectionState previousState = tcb.state;
				/** Keep previous state so it can return to this state if closing fails */
				tcb.state = ConnectionState.FIN_WAIT_1;
				bytesSent = send_fin();
				System.out.printf("CLOSE:%d FIN packet should be send correctly state: %s\n", tcb.src_port, tcb.state);//TODO Remove prints
				if (bytesSent == -1) {
					System.out.printf("CLOSE:%d FIN packet did not send correctly state: %s\n", tcb.src_port, tcb.state);//TODO Remove print
					return true;
					/** Failed to send FIN to client/server, but return because there was a connection */
				}
				/** Receive a FIN, ACK or FINACK from here*/
				if (tcb.state.equals(ConnectionState.FIN_WAIT_2)) {
					System.out.printf("CLOSE:%d FIN packet was send succesfully and answered with an ACK\n" +
							"\tshould be in state FIN_WAIT_2 -> state: %s\n" +
							"will now wait for the following FIN packet...\n", tcb.src_port, tcb.state);//TODO Remove print
					/** Received ACK in FIN_WAIT_1, Regular Client Close */
					recv_tcp_packet(true); //Receive closing FIN packet from other party
					System.out.printf("CLOSE:%d received a packet correctly,\n" +
							"\t should have been a FIN packet and hence should be in TIME_WAIT now -> state: %s\n" +
							"\tAlso, send ack to acknowledge the fin packet received\n", tcb.src_port, tcb.state);//TODO Remove print
					/** Wait for last fin, afterwards in TIME_WAIT state and leaves this if */
					bytesSent = send_ack();
					System.out.printf("CLOSE:%d Sending ack should have ben succesfull | state: %s\n", tcb.src_port, tcb.state);//TODO Remove print
					/** Send clients last ACK; afterward go to TIME_WAIT */
					if (bytesSent == -1) {
						System.out.printf("CLOSE:%d Sending ack was unsuccesfull...state: %s\n", tcb.src_port, tcb.state);//TODO Remove print
						tcb.state = previousState;
						return true;
						/** Failed to send LAST_ACK to Server, but return because there was a connection */
					}
				}
				else if (tcb.state.equals(ConnectionState.CLOSING)) {
					System.out.printf("CLOSE:%d Trying to close from Closing state because we received a FIN to our FIN packet -> state: %s\n" +
							"\t Hence, simultaneous close. Will thus send a ACK to the CLOSING stateholding otherside to note we are done\n", tcb.src_port, tcb.state);//TODO Remove print
					/** Received FIN in FIN_WAIT_1 */
					bytesSent = send_ack();
					System.out.printf("CLOSE:%d Sending ack should have been succesfull | state: %s\n", tcb.src_port, tcb.state);//TODO Remove print
					/** Send clients last ack, afterwards in TIME_WAIT state */
					if (bytesSent == -1) {
						System.out.printf("CLOSE:%d Sending an ACK was unsuccesfull...state: %s\n", tcb.src_port, tcb.state);//TODO Remove print
						tcb.state = previousState;
						return true;
						/** Failed to send LAST_ACK to Server, but return because there was a connection */
					}
					System.out.printf("CLOSE:%d Will now wait for the remaining ack on our ack | state: %s\n", tcb.src_port, tcb.state);//TODO Remove print
					recv_tcp_packet(true); //Wait for ACK, recv_ack() will push it to state TIME_WAIT
					System.out.printf("CLOSE:%d Should have received another ack\n\tshould be in state TIME_WAIT -> state: %s\n", tcb.src_port, tcb.state);//TODO Remove print
				}
				else if (tcb.state.equals(ConnectionState.TIME_WAIT)) {
					System.out.printf("CLOSE:%d Received a FINACK to our FIN, hence we move to TIME_WAIT state -> state: %s\n" +
							"\twe will send an ACK to their FINACK in response...\n", tcb.src_port, tcb.state);//TODO Remove print
					/** Received FINACK in FIN_WAIT_1 */
					bytesSent = send_ack();
					System.out.printf("CLOSE:%d Sending ack should have been succesfull...state: %s\n", tcb.src_port, tcb.state);//TODO Remove print
					/** Send clients last ack, afterwards in TIME_WAIT state */
					if (bytesSent == -1) {
						System.out.printf("CLOSE:%d Sending ack was unsuccesfull...state: %s\n", tcb.src_port, tcb.state);//TODO Remove print
						tcb.state = previousState;
						return true;
						/** Failed to send LAST_ACK to Server, but return because there was a connection */
					}
				}
			}
			else if (tcb.state.equals(ConnectionState.CLOSE_WAIT)) {
				System.out.printf("CLOSE:%d Received a FIN before we called close, hence state = %s\n" +
						"\twe move to state LAST_ACK and send a FIN packet in response\n", tcb.src_port, tcb.state);//TODO Remove print
				tcb.state = ConnectionState.LAST_ACK;
				bytesSent = send_fin();
				System.out.printf("CLOSE:%d FIN packet should have been send succesfully | state: %s\n", tcb.src_port, tcb.state);//TODO Remove print
				if (bytesSent == -1) {
					System.out.printf("CLOSE:%d Sending FIN packet was unsuccesfull...state: %s\n", tcb.src_port, tcb.state);//TODO Remove print
					tcb.state = ConnectionState.CLOSE_WAIT;
					return true;
					/** Failed to send FIN to client/server, but return (also to previous state) because there was a connection */
				}
			}
			
			//TODO this if is probably useless, since there is no way anyother state than TIME_WAIT can be reached here
			if (tcb.state.equals(ConnectionState.TIME_WAIT)) {
				/** Send the last ack and wait */
				try {
					System.out.printf("CLOSE:%d Almost done, we are now in TIME_WAIT, thus only need to wait\n", tcb.src_port);//TODO Remove print
					Thread.sleep(TIMEOUT * 1000);
					System.out.printf("CLOSE:%d DONE!\n", tcb.src_port);//TODO Remove print
					/** TIMEOUT is 60 seconds */
				} catch (InterruptedException e) {
					e.printStackTrace();
				}
				tcb.clean();
				System.out.printf("CLOSE:%d TCB cleaned up in TIME_WAIT state\n", tcb.src_port);//TODO Remove print
			}
			return true;
		}
		
		/**
		 * Helper method to call an error message from
		 * 
		 * @param type: number indicating from which method the call originated
		 * 		1. listen() / accept()
		 * 		2. write()
		 * 		3. read()
		 * 		4. close() 
		 */
		private void errorMessage(int type) {
			if (type == 1) {
				/** from method listen() / accept() */
				System.err.println("Error: connection already exists");
			}
			else if (type == 2) {
				/** from method write() */
				if (tcb.state.equals(ConnectionState.CLOSED)) {
					System.err.println("Error: connection does not exist");
				}
				if (tcb.state.equals(ConnectionState.LISTEN) || tcb.state.equals(ConnectionState.SYN_SENT) ||
						tcb.state.equals(ConnectionState.SYN_RCVD)) {
					System.err.println("Error: connection does not exist; still trying to connect");
				}
				if (tcb.state.equals(ConnectionState.FIN_WAIT_1) || tcb.state.equals(ConnectionState.FIN_WAIT_2) ||
						tcb.state.equals(ConnectionState.CLOSING) || tcb.state.equals(ConnectionState.LAST_ACK) ||
						tcb.state.equals(ConnectionState.TIME_WAIT)) {
					System.err.println("Error: connection closing");
				}
			}
			else if (type == 3) {
				/** from method read() */
				if (tcb.state.equals(ConnectionState.CLOSED)) {
					System.err.println("Error: connection does not exist");
				}
				if (tcb.state.equals(ConnectionState.LISTEN) || tcb.state.equals(ConnectionState.SYN_SENT) ||
						tcb.state.equals(ConnectionState.SYN_RCVD)) {
					System.err.println("Error: connection does not exist; still trying to connect");
				}
				if (tcb.state.equals(ConnectionState.CLOSING) || tcb.state.equals(ConnectionState.LAST_ACK) ||
						tcb.state.equals(ConnectionState.TIME_WAIT)) {
					System.err.println("Error: connection closing");
				}
			}
			else if (type == 4) {
				/** from method close() */
				if (tcb.state.equals(ConnectionState.CLOSED)) {
					System.err.println("Error: connection does not exist");
				}
				if (tcb.state.equals(ConnectionState.FIN_WAIT_1) || tcb.state.equals(ConnectionState.FIN_WAIT_2) ||
						tcb.state.equals(ConnectionState.CLOSING) || tcb.state.equals(ConnectionState.LAST_ACK) ||
						tcb.state.equals(ConnectionState.TIME_WAIT)) {
					System.err.println("Error: connection closing");
				}
			}
			else {
				System.err.println("Error: trying to send unknown error");
			}
		}
	}
	
	/**
	* Constructs a TCP stack for the given virtual address.
	* The virtual address for this TCP stack is then
	* 192.168.1.address.
	*
	* @param address: Integer storing the last octet of the virtual IP address (1-254)
	* @throws IOException: if the IP stack fails to initialize.
	*/
	public TCP(int address) throws IOException {
		ip = new IP(address);
		tcb = new TCB(ip.getLocalAddress());
		/** Initialization of the source sequence number */
		tcb.isseqnum = new Random().nextInt(250);
	}
	
	/**
	* @return a new socket for this stack
	*/
	public Socket socket() {
		return new Socket();
	}
	
	/**
	* @return a new server socket for this stack bound to the given port
	* @param port the port to bind the socket to.
	*/
	public Socket socket(int port) {
		return new Socket(port);
	}
	
	/****************************************************************************************
	 * 									Sending Methods			 							*
	 ****************************************************************************************/
	
	/**
	 * Method to send a 'synchronize'(SYN) request message to the destination port
	 * 
	 * @return the number of bytes sent as an integer
	 * 	-1 in case of failed sending and bytesSent in case packet is received
	 */
	public int send_syn() {
		System.out.printf("SEND_SYN:%d Entered send_syn() method\n", tcb.src_port);//TODO remove print
		int bytesSent = 0, bytesRead = 0, numRetransmission = NUM_RETRANSMISSION;
		byte flags = (byte) 0;
		if (tcb.state.equals(ConnectionState.SYN_SENT)) {
			/** Active socket sending the first SYN for the connection */
			flags = PSH | SYN;
		}
		else if (tcb.state.equals(ConnectionState.SYN_RCVD)) {
			/** Passive socket which already received a SYN sends SYNACK back to client */
			flags = PSH | SYN | ACK;
		}
		else {
			/** Not in the states LISTEN or CLOSED, hence inappropriate method access */
			System.err.println("Error: not in state LISTEN or CLOSED\n\tcannot send a SYN packet");
			return -1;
		}
		
		while (numRetransmission > 0) {
			System.out.printf("SEND_SYN:%d sending SYN packet number %d\n", tcb.src_port, NUM_RETRANSMISSION + 1 - numRetransmission); //TODO Remove print
			bytesSent = send_tcp_packet(tcb.dest_ipaddr, tcb.dest_port, tcb.src_port, tcb.src_seqnum, tcb.dest_seqnum, flags, (short) 0, new byte[0], 0);
			if (bytesSent == -1) {
				System.err.printf("Error: sending SYN packet failed");
				return -1;
			}
			else {
				/** 
				 * Our sequence number will be increased to ISS + 1, the seqnum
				 *  we will use on our next message
				 * Expected_acknum set to ISS, since that is what we atleast
				 *  expect to be acknowledged
				 **/
				tcb.src_seqnum = (tcb.isseqnum + 1) % Integer.MAX_VALUE;
				tcb.expected_acknum = tcb.isseqnum;
				System.out.printf("SEND_SYN:%d isseqnum: %d src_seqnum: %d expected_acknum: %d\n", tcb.src_port, tcb.isseqnum, tcb.src_seqnum, tcb.expected_acknum);//TODO remove print
			}
			
			bytesRead = recv_tcp_packet(true);
			if (bytesRead > 0) {
				/** CONNECT: Receiving the synack for the SYN request ACCEPT: Receiving the ack for the SYN send */
				return bytesSent;
			}
			System.out.printf("SEND_SYN:%d Sending SYN packet failed, going to retry to transmission %d\n", tcb.src_port, numRetransmission - 1);
			numRetransmission--;
		}
		System.err.printf("Error: sending SYN packet failed ten times");
		return -1;
	}
	
	/**
	 * Method to send an 'acknowledgement'(ACK) message to the destination port
	 * 
	 * @return the number of bytes sent as an integer
	 */
	public int send_ack() {
		int bytesSent = 0, numRetransmission = NUM_RETRANSMISSION;
		byte flags = PSH | ACK;
		
		while (numRetransmission > 0) {
			System.out.printf("SEND_ACK:%d sending ACK packet number %d\n", tcb.src_port, NUM_RETRANSMISSION + 1 - numRetransmission); //TODO Remove print
			bytesSent = send_tcp_packet(tcb.dest_ipaddr, tcb.dest_port, tcb.src_port, tcb.src_seqnum, tcb.dest_seqnum, flags, (short) 0, new byte[0], 0);
			if (bytesSent >= 0) {
				break;
			}
			System.err.printf("Error: sending ACK packet failed");
			numRetransmission--;
		}
		if (numRetransmission == 0) {
			System.err.printf("Error: sending ACK packet failed ten times");
			return -1;
		}
		return bytesSent;
	}
	
	/**
	 * Method to send a data message to the destination port
	 * 
	 * @return the number of bytes sent as an integer
	 */
	public int send_data() {
		int bytesSent = 0, bytesRead = 0, dataSize = tcb.packet_data.length, numRetransmission = NUM_RETRANSMISSION;
		byte flags = PSH;
		if (!tcb.state.equals(ConnectionState.ESTABLISHED) && !tcb.state.equals(ConnectionState.CLOSE_WAIT)) {
			/** Not in the states ESTABLISHED or CLOSE_WAIT, hence inappropriate method access */
			System.err.println("Error: not in state ESTABLISHED or CLOSE_WAIT\n\tcannot send a data packet");
			return -1;
		}
		
		while (numRetransmission > 0) {
			System.out.printf("SEND_DATA:%d sending data packet number %d\n", tcb.src_port, NUM_RETRANSMISSION + 1 - numRetransmission); //TODO Remove print
			bytesSent = send_tcp_packet(tcb.dest_ipaddr, tcb.dest_port, tcb.src_port, tcb.src_seqnum, tcb.dest_seqnum, flags, (short) 0, tcb.packet_data, dataSize);
			if (bytesSent == -1) {
				System.err.printf("Error: sending data packet failed");
				return -1;
			}
			else {
				/** Expected acknum should equal what we want them to at least acknowledge */
				tcb.src_seqnum = (tcb.src_seqnum + (bytesSent - 20)) % Integer.MAX_VALUE;
				tcb.expected_acknum = tcb.src_seqnum;
				System.out.printf("SEND_DATA:%d Sending data was succesfull\n\t" +
						"src_seqnum: %d expected_acknum: %d\n", tcb.src_port, tcb.src_seqnum, tcb.expected_acknum);//TODO remove print
			}
			System.out.printf("SEND_DATA:%d Will now try to receive an ACK to our data send\n", tcb.src_port);
			bytesRead = recv_tcp_packet(true);
			if (bytesRead > 0) {
				/** Receiving the acknowledgement that the data has arrived */
				System.out.printf("SEND_DATA:%d Receiving ACK was succesfull\n", tcb.src_port);
				return bytesSent;
			}
			/** in case of else: failed, hence recent data */
			System.out.printf("SEND_DATA:%d Sending data packet failed, going to retry to transmission %d\n", tcb.src_port, numRetransmission - 1);
			numRetransmission--;
		}
		System.err.printf("Error: sending data packet failed ten times");
		return -1;
	}
	
	/**
	 * Method to send a 'finish'(FIN) request message to the destination port
	 * 
	 * @return the number of bytes sent as an integer
	 */
	public int send_fin() {
		int bytesSent = 0, bytesRead = 0, numRetransmission = NUM_RETRANSMISSION;
		byte flags = (PSH | FIN);
		if (!tcb.state.equals(ConnectionState.FIN_WAIT_1) && !tcb.state.equals(ConnectionState.LAST_ACK)) {
			/** Not in the states SYN_RCVD, ESTABLISHED or CLOSE_WAIT, hence inappropriate method access */
			System.err.println("Error: not in state FIN_WAIT_1 or LAST_ACK\n\tcannot send a FIN packet");
			return -1;
		}
		
		while (numRetransmission > 0) {
			System.out.printf("SEND_FIN:%d sending FIN packet number %d\n", tcb.src_port, NUM_RETRANSMISSION + 1 - numRetransmission); //TODO Remove print
			bytesSent = send_tcp_packet(tcb.dest_ipaddr, tcb.dest_port, tcb.src_port, tcb.src_seqnum, tcb.dest_seqnum, flags, (short) 0, new byte[0], 0);
			if (bytesSent == -1) {
				System.err.printf("Error: sending FIN packet failed");
				System.out.printf("SEND_FIN:%d ERROR SENDING FIN\n", tcb.src_port);//TODO remove
				return -1;
			}
			else {
				/** Expected acknum should equal what we want them to acknowledge */
				tcb.src_seqnum = (tcb.src_seqnum + 1) % Integer.MAX_VALUE;
				tcb.expected_acknum = tcb.src_seqnum;
			}
			
			bytesRead = recv_tcp_packet(true);
			if (bytesRead > 0) {
				System.out.printf("SEND_FIN:%d packet in response to FIN packet received\n\tshould have been an ACK\n", tcb.src_port);//TODO remove
				/** Receiving the acknowledgement that the fin has arrived */
				return bytesSent;
			}
			System.out.printf("SEND_FIN:%d Sending FIN packet failed, going to retry to transmission %d\n", tcb.src_port, numRetransmission - 1);
			numRetransmission--;
		}
		System.err.printf("Error: sending FIN packet failed ten times");
		return -1;
	}
	
	/**
	 * Base sending method of tcp packets
	 * 
	 * @param dest_ipaddr: The destination IP address to send to
	 * @param dest_port: The port to which the packet will be send
	 * @param src_port: The port from which the packet will originate
	 * @param seqnum: The sequence number for this packet
	 * @param acknum: The acknowlegde number for this packet
	 * @param flags: The flags for this packet
	 * @param window_size: The windows size for this packet (not used)
	 * @param data: The data which this packet will send
	 * @param data_size: The size of the data in this packet
	 * @return The number of bytes send as an integer
	 *  -1 in case of error and 0 or higher in case of success
	 */
	public int send_tcp_packet(IpAddress dest_ipaddr, short dest_port, short src_port, int seqnum, int acknum, byte flags, short window_size, byte[] data, int data_size) {
		int bytesSent;
		short checksum = 0;
		short urg_pointer = 0;
		byte data_offset = 0x16;//TODO correct offset?
		
		//System.out.printf("Trying to send ...\nsrc port: %d\ndst port: %d\nsrc addr: %d\ndst addr: %d\n", src_port, dest_port, ip.getLocalAddress().getAddress(), dest_ipaddr.getAddress()); //TODO Remove print
		
		/** The data starts after 20 bytes permenantly, since we do not use any options */
		
		TcpHeader tcpHead = new TcpHeader(src_port, dest_port, seqnum, acknum, data_offset, flags, window_size, checksum, urg_pointer);
		tcpHead.data_offset = (byte) tcpHead.length();
		TcpSegment tcpSeg = new TcpSegment(tcpHead, data);
		PseudoHeader ph = new PseudoHeader(ip.getLocalAddress(), dest_ipaddr, (short) 0, (short) IP.TCP_PROTOCOL, tcpSeg.length());
		tcpSeg.setChecksum(tcpSeg.computeChecksum(ph));
		
		Packet p = null;
		try {
			p = new Packet(dest_ipaddr.getAddress(), IP.TCP_PROTOCOL, 2, tcpSeg.getByteArray(), tcpSeg.length());
		} catch (IOException e1) {
			e1.printStackTrace();
		}
		
		try {
			System.out.printf("SND_TCP_PAC:%d Sending packet...\n", tcb.src_port);//TODO Remove print
			bytesSent = ip.ip_send(p);
			System.out.printf("SND_TCP_PAC:%d Sent %d bytes (datalength + tcpheader) \n", tcb.src_port, bytesSent); //TODO Remove print
		} catch (IOException e) {
			e.printStackTrace();
			bytesSent = -1;
		}
		/** Return bytesSent - 20 for the TCP Header length, which is 20 bytes TODO changed this to removing the 20 in write and acknum setting respectively*/
		return bytesSent;
	}
	
	/****************************************************************************************
	 * 									Receiving Methods 									*
	 ****************************************************************************************/
	
	/**
	 * Base method to receive the ip packets
	 * 
	 * @param waitingReceive: boolean dictating the type of receive method used
	 * @return the number of bytes received as an integer
	 */
	public int recv_tcp_packet(boolean waitingReceive) {
		System.out.printf("RCV_TCP_PAC:%d State before receiving: %s\n", tcb.src_port, tcb.state);//TODO remove print
		Packet p = new Packet(0, 0, 0, new byte[0], 0);
		/** Initial empty packet to store incoming packet */
		TcpSegment s = new TcpSegment();
		PseudoHeader ph = new PseudoHeader();
		
		try {
			System.out.printf("RCV_TCP_PAC:%d Receiving packet...\n", tcb.src_port);//TODO remove print
			how_to_receive(p, waitingReceive);
			System.out.printf("RCV_TCP_PAC:%d Packet received...\n", tcb.src_port);//TODO remove print
		} catch (IOException e) {
			System.err.println("IO Error: IP layer failed to receive");
			System.out.printf("RCV_TCP_PAC:%d io ~\n", tcb.src_port); //TODO Remove print
			return -1;
		} catch (InterruptedException e) {
			System.err.println("Interrupted Error: IP layer failed to receive");
			System.out.printf("RCV_TCP_PAC:%d Timeout ~\n", tcb.src_port); //TODO Remove print
			return -1;
		}
		
		if (p.protocol != IP.TCP_PROTOCOL) {
			System.err.println("Error: incorrect protocol packet received");
			System.out.printf("RCV_TCP_PAC:%d incorrect protocol ~\n", tcb.src_port);
			return -1;
		}
		
		s = decodePacket(p);
		/** Writes all packet info to a tcp segment */
		ph = new PseudoHeader(IP.IpAddress.getAddress(p.source), IP.IpAddress.getAddress(p.destination), (short) 0, (short) IP.TCP_PROTOCOL, s.length());
		
		if (!s.validateChecksum(ph)) {
			System.out.printf("RCV_TCP_PAC:%d Got invalid checksum...\n", tcb.src_port); //TODO Remove print
			return -1;
		}
		if (!correct_recvd_packet(s, ph)) {
			System.out.printf("RCV_TCP_PAC:%d Got incorrect packet...\n", tcb.src_port); //TODO Remove print
			return -1;
		}
		
		if (tcb.state.equals(ConnectionState.CLOSED)) {
			System.err.println("Error: no connection | cannot receive any messages");
			return -1;
		}
		else if (tcb.state.equals(ConnectionState.LISTEN) || tcb.state.equals(ConnectionState.SYN_SENT)) {
			/** Should only be able to receive a SYN/SYNACK here */
			if (recv_syn(s)) {
				return s.length();
			}
			else {
				return -1;
			}
		} //TODO not sure if it should be equal to or >= (noted on page 68 in RFC793, I ignore the other states, because we dont use a window)
		else if (s.tcpHeader.seqnum >= tcb.dest_seqnum) { //TODO CHANGED THIS AFTER ESTABLISHED STATE (ACKNUM COULD NOT ARRIVE)
			/** 
			 * If in state SYN_RCVD, ESTABLISHED, FIN_WAIT_1, FIN_WAIT_2, CLOSE_WAIT
			 *  CLOSING, LAST_ACK or TIME_WAIT we may expect the messages can be sent in sequence
			 */
			if (recv_syn(s) || recv_ack(s) || recv_data(s) || recv_fin(s)) {
				System.out.printf("RCV_TCP_PAC:%d State after receiving: %s\n", tcb.src_port, tcb.state);//TODO remove print
				return s.length();
			}
			else {
				return -1;
			}
		}
		else {
			//TODO maybe send an ack from here (see end page 68 of RFC793), to make sure we acked their messages
			System.out.printf("RCV_TCP_PACK:%d After state and seqnum checking, those thus failed...\n\tState: %s SegmentSeqnum: %d (>=) DestSeqnum %d\n", tcb.src_port, s.tcpHeader.seqnum, tcb.dest_seqnum);
			System.err.println("Error: incorrect sequence numbering");
			return -1;
		}
		//TODO From here on changed!
		//		System.out.printf("Got here...\n");
		//		
		//		/** 
		//		 * State setting and ack/dest_seqnum setting through segment 
		//		 * We may assume receiving has all gone well from here on, 
		//		 * hence no need to reset possible set states and ack/dest_seqnums 
		//		 */
		//		//		&& tcb.dest_seqnum <= segment.tcpHeader.seqnum //Check whether the seqnum of the packet equals the seqnum we expect 
		//		//				&& tcb.expected_acknum >= segment.tcpHeader.acknum) { //Check whether the data we send is the data they acknowledge
		//		
		//		if (tcb.expected_acknum == s.tcpHeader.acknum) {
		//			recv_ack(s);
		//			recv_data(s);
		//			recv_syn(s);
		//			recv_fin(s);
		//			System.out.printf("State after receiving: %s\n", tcb.state);//TODO remove print
		//			return s.length();
		//		}
		//		else {
		//			return -1;
		//		}
		//		/** s.length equals bytesRead */
	}
	
	/**
	 * Switching method between the ip_receive_timeout method
	 * 	and the ip_receive method
	 * 
	 * @param p: The packet which will store the received information
	 * @param waitingReceive: the boolean which dictates if
	 * 	ip_receive_timeout or ip_receive will be used
	 * @throws InterruptedException 
	 * @throws IOException 
	 */
	public void how_to_receive(Packet p, boolean waitingReceive) throws IOException, InterruptedException {
		if (waitingReceive) {
			ip.ip_receive_timeout(p, TIMEOUT);
		}
		else {
			ip.ip_receive(p);
		}
	}
	
	/**
	 * Method which decodes an incoming packet into a 
	 * 	TCP segment
	 * 
	 * @param p: the received packet
	 * @return a TCP segment containing all the relevant data from the packet
	 */
	public TcpSegment decodePacket(Packet p) {
		short src_port = (short) 0;
		short dest_port = (short) 0;
		int seqnum = 0;
		int acknum = 0;
		byte data_offset = (byte) 0;
		byte flags = (byte) 0;
		short window_size = 0;
		short checksum = (short) 0;
		short urg_pointer = (short) 0;
		byte[] data = new byte[TCB.BUF_SIZE];
		
		ByteBuffer shortBuffer = ByteBuffer.allocate(2);
		ByteBuffer intBuffer = ByteBuffer.allocate(4);
		shortBuffer.order(ByteOrder.BIG_ENDIAN);
		intBuffer.order(ByteOrder.BIG_ENDIAN);
		
		shortBuffer.put(p.data[0]);
		shortBuffer.put(p.data[1]);
		shortBuffer.rewind();
		src_port = shortBuffer.getShort(); //SRC_PORT
		//System.out.printf("Src Port: %d\n", src_port); //TODO Remove print
		shortBuffer.rewind();
		shortBuffer.put(p.data[2]);
		shortBuffer.put(p.data[3]);
		shortBuffer.rewind();
		dest_port = shortBuffer.getShort(); //DEST_PORT
		//System.out.printf("Dest Port: %d\n", dest_port); //TODO Remove print
		shortBuffer.rewind();
		intBuffer.put(p.data[4]);
		intBuffer.put(p.data[5]);
		intBuffer.put(p.data[6]);
		intBuffer.put(p.data[7]);
		intBuffer.rewind();
		seqnum = intBuffer.getInt(); //SEQNUM
		intBuffer.rewind();
		intBuffer.put(p.data[8]);
		intBuffer.put(p.data[9]);
		intBuffer.put(p.data[10]);
		intBuffer.put(p.data[11]);
		intBuffer.rewind();
		acknum = intBuffer.getInt(); //ACKNUM
		intBuffer.rewind();
		data_offset = p.data[12]; //DATA_OFFSET
		flags = p.data[13]; //FLAGS
		shortBuffer.put(p.data[14]);
		shortBuffer.put(p.data[15]);
		shortBuffer.rewind();
		window_size = shortBuffer.getShort(); //WINDOW_SIZE
		shortBuffer.rewind();
		shortBuffer.put(p.data[16]);
		shortBuffer.put(p.data[17]);
		shortBuffer.rewind();
		checksum = shortBuffer.getShort(); //CHECKSUM
		shortBuffer.rewind();
		shortBuffer.put(p.data[18]);
		shortBuffer.put(p.data[19]);
		shortBuffer.rewind();
		urg_pointer = shortBuffer.getShort(); //URG_POINTER
		shortBuffer.rewind();
		data = new byte[p.length - 20]; //DATA
		System.arraycopy(p.data, 20, data, 0, p.length - 20);
		
		return new TcpSegment(new TcpHeader(src_port, dest_port, seqnum, acknum, data_offset, flags, window_size, checksum, urg_pointer), data);
	}
	
	/**
	 * Checks whether the packet sends corresponds with what expected
	 *  Checks if addresses and ports corresponds with what is required
	 * 
	 * @param segment: TCPSegment containing the received Packets TCP info
	 * @param ph: Pseudoheader containing the received Packets IP info
	 * @return True if it was a correct packet | False if it was an incorrect packet
	 */
	public boolean correct_recvd_packet(TcpSegment segment, PseudoHeader ph) {
		if (tcb.dest_ipaddr.getAddress() == 0) {
			tcb.dest_ipaddr = ph.src_ipaddr;
		}
		if (tcb.src_port == 0) {
			tcb.src_port = segment.tcpHeader.dest_port;
		}
		if (tcb.dest_port == 0) {
			tcb.dest_port = segment.tcpHeader.src_port;
		}
		System.out.printf("COR_RCV_PACK:%d Packet details:\n" +
				"  TCB_dest_ipaddr: %d\tPH_dest_ipaddr: %d\n" +
				"  TCB_src_port: %d\tSGMT_dest_port: %d\n" +
				"  TCB_dest_port: %d\tSGMT_src_port: %d\n" +
				"  FLAGS:\tSYN:%b ACK:%b FIN:%b\n" +
				"  TCB_src_seqnum: %d\tTCB_dest_seqnum: %d\n" +
				"  SGMT_seqnum: %d\tSGMT_acknum: %d\n",
				tcb.src_port,
				tcb.dest_ipaddr.getAddress(), ph.dest_ipaddr.getAddress(),
				tcb.src_port, segment.tcpHeader.dest_port,
				tcb.dest_port, segment.tcpHeader.src_port,
				(segment.tcpHeader.flags & SYN) == SYN, (segment.tcpHeader.flags & ACK) == ACK, (segment.tcpHeader.flags & FIN) == FIN,
				tcb.src_seqnum, tcb.dest_seqnum,
				segment.tcpHeader.seqnum, segment.tcpHeader.acknum);
		if (tcb.dest_ipaddr.getAddress() == ph.src_ipaddr.getAddress() && tcb.src_port == segment.tcpHeader.dest_port &&
				tcb.dest_port == segment.tcpHeader.src_port) { //Check whether the data we send is the data they acknowledge
			System.out.printf("COR_RCV_PACK:%d Packet was valid\n", tcb.src_port);
			return true;
		}
		System.out.printf("COR_RCV_PACK:%d Packet was INvalid\n", tcb.src_port);
		return false;
	}
	
	/**
	 * Receive a syn packet and based on the connection state
	 *  move to a follow up state
	 *   Inherently, receiving the syn is the second step of the 
	 *   3-way-handshake
	 * Only implement regular connect, not simultaneous connect.
	 * Follows from only accepting SYNACKs in SYN_SENT state and 
	 *  not accepting SYNs in SYN_SENT state
	 * If it is a SYN packet, set the acknowledgment and
	 *  destination sequence number according to the segment received
	 * 
	 * @param flags: byte variable for the flags of the packet received
	 */
	public boolean recv_syn(TcpSegment s) {
		System.out.printf("RECV_SYN:%d Checking Syn...\n", tcb.src_port);//TODO remove print
		if (s.tcpHeader.flags != (PSH | SYN) && s.tcpHeader.flags != (PSH | SYN | ACK)) {
			return false;
		}
		if (!tcb.state.equals(ConnectionState.LISTEN) && !tcb.state.equals(ConnectionState.SYN_SENT)) {
			return false;
		}
		
		if (tcb.state.equals(ConnectionState.LISTEN) && s.tcpHeader.flags == (PSH | SYN)) {
			/** Server receives SYN from Client 
			 * Acknum to send should equal the seqnum received plus one
			 *  because that is what they expect */
			tcb.dest_seqnum = (s.tcpHeader.seqnum + 1) % Integer.MAX_VALUE;// for comparisons
			tcb.irseqnum = s.tcpHeader.seqnum;
			tcb.state = ConnectionState.SYN_RCVD;
			System.out.printf("RECV_SYN:%d Received SYN packet in Listen state\n" +
					"\tDestSeqnum: %d SegmentSeqNum: %d IRS: %d State: %s\n",
					tcb.src_port, tcb.dest_seqnum, s.tcpHeader.seqnum, tcb.irseqnum, tcb.state);//TODO remove
			return true;
		}
		else if (tcb.state.equals(ConnectionState.SYN_SENT) && s.tcpHeader.flags == (PSH | SYN | ACK)) {
			/** Only if the acknum is above or equal to the acknum we expect and below or equal to our seqnum, it's a valid SYNACK to be received in the SYN_SENT state */
			if (tcb.expected_acknum <= s.tcpHeader.acknum && s.tcpHeader.acknum <= tcb.src_seqnum) {
				/** Clients receives SYNACK from Server 
				 * Acknum to send should equal the seqnum received plus one
				 *  because that is what they expect */
				tcb.dest_seqnum = (s.tcpHeader.seqnum + 1) % Integer.MAX_VALUE;
				tcb.irseqnum = s.tcpHeader.seqnum;
				tcb.expected_acknum = s.tcpHeader.acknum;
				tcb.state = ConnectionState.ESTABLISHED;
				System.out.printf("RECV_SYN:%d Received SYNACK packet in SYN_SENT state\n" +
						"\tDestSeqnum: %d SegmentSeqNum: %d IRS: %d ExpectedAcknum: %d SegmentAcknum: %d State: %s\n",
						tcb.src_port, tcb.dest_seqnum, s.tcpHeader.seqnum, tcb.irseqnum, tcb.expected_acknum, s.tcpHeader.acknum, tcb.state);//TODO remove
				return true;
			}
			else {
				System.out.printf("RECV_SYN:%d ExpectedAcknum: %d SegmentAcknum: %d SourceSeqnum: %d\n", tcb.src_port, tcb.expected_acknum, s.tcpHeader.acknum, tcb.src_seqnum);//TODO remove
				System.err.println("Error: segment acknowledgment number incorrect");
				return false;
			}
		}
		System.out.printf("RECV_SYN:%d Incorrent flags/state combination\n\tState: %s Flags: SYN=%b ACK=%b FIN=%b\n", tcb.src_port, tcb.state, (s.tcpHeader.flags & SYN) == SYN, (s.tcpHeader.flags & ACK) == ACK, (s.tcpHeader.flags & FIN) == FIN);
		System.err.println("Error: incorrect state/flags combination for receiving SYN");
		return false;
		
	}
	
	/**
	 * Receive an ACK packet and based on the flags and current process
	 *  state, possibly change the state.
	 * Only instances were a sole ACK packet changes state,
	 *  is during the Handshake and Close steps.
	 * If it is an ACK packet, set the source sequence number 
	 *  according to the segment received
	 * 
	 * @param flags: byte variable for the flags of the packet received
	 */
	public boolean recv_ack(TcpSegment s) {
		System.out.printf("RECV_ACK:%d Checking ACK Flags...\n", tcb.src_port);//TODO Remove print
		if (s.tcpHeader.flags != (PSH | ACK)) {
			return false;
		}
		System.out.printf("RECV_ACK:%d Checking State...\n", tcb.src_port);//TODO Remove print
		if (!tcb.state.equals(ConnectionState.SYN_RCVD) && !tcb.state.equals(ConnectionState.ESTABLISHED) &&
				!tcb.state.equals(ConnectionState.FIN_WAIT_1) && !tcb.state.equals(ConnectionState.CLOSE_WAIT) &&
				!tcb.state.equals(ConnectionState.CLOSING) && !tcb.state.equals(ConnectionState.LAST_ACK)) {
			System.out.printf("RECV_ACK:%d SHOULD NOT GET HERE! STATE: %s\n", tcb.src_port, tcb.state); //TODO Remove print
			return false;
		}
		
		/** 
		 * HANDSHAKE
		 * Server receive ack in syn_rcvd state 
		 **/
		System.out.printf("RECV_ACK:%d GOT ACK! STATE: %s\n", tcb.src_port, tcb.state); //TODO Remove print
		if (tcb.state.equals(ConnectionState.SYN_RCVD)) {
			if (tcb.expected_acknum <= s.tcpHeader.acknum && s.tcpHeader.acknum <= tcb.src_seqnum) {
				System.out.printf("RECV_ACK:%d received ack in %s state, will move to ESTABLISHED\n" +
						"\tConnection Established!\n", tcb.src_port, tcb.state); //TODO Remove print
				System.out.printf("RECV_ACK:%d SERVER: CONNECTION ESTABLISHED!\n", tcb.src_port); //TODO Remove print
				tcb.state = ConnectionState.ESTABLISHED;
				return true;
			}
			else {
				System.out.printf("RECV_ACK:%d received incorrect ack in SYN_RCVD state\n" +
						"\texpected_acknum %d <= segment_acknum %d <= source_seqnum %d | was false", 
						tcb.src_port, tcb.expected_acknum, s.tcpHeader.acknum, tcb.src_seqnum); //TODO Remove print
			}
		}
//		else if (tcb.state.equals(ConnectionState.ESTABLISHED) || tcb.state.equals(ConnectionState.CLOSE_WAIT)) {
//			if (tcb.expected_acknum < s.tcpHeader.acknum && s.tcpHeader.acknum <= tcb.src_seqnum) {
//				System.out.printf("RECV_ACK:%d received ack in %s state, will move to ESTABLISHED\n" +
//						"\tConnection Established!\n", tcb.src_port, tcb.state); //TODO Remove print
//				tcb.expected_acknum = s.tcpHeader.acknum;
//				tcb.state = ConnectionState.ESTABLISHED;
//				return true;
//			}//TODO remove? Not sure if this is needed
//			else {
//				System.out.printf("RECV_ACK:%d received incorrect ack in %s state\n" +
//						"\texpected_acknum %d <= segment_acknum %d <= source_seqnum %d | was false", 
//						tcb.src_port, tcb.state, tcb.expected_acknum, s.tcpHeader.acknum, tcb.src_seqnum); //TODO Remove print
//			}
//		}
		/**
		 * CLOSE 
		 * 1. Client receive ack in fin_wait_one state
		 * 2. Server receive ack in last_ack state 
		 **/
		else if (tcb.state.equals(ConnectionState.FIN_WAIT_1)) {
			//if (tcb.expected_acknum <= s.tcpHeader.acknum && s.tcpHeader.acknum <= tcb.src_seqnum) {
				System.out.printf("RECV_ACK:%d received ack in FIN_WAIT_1 state, will move to FIN_WAIT_2\n", tcb.src_port); //TODO Remove print
				tcb.state = ConnectionState.FIN_WAIT_2;
				return true;
//			}
//			else {
//				System.out.printf("RECV_ACK:%d received incorrect ack in FIN_WAIT_1 state\n" +
//						"\texpected_acknum %d <= segment_acknum %d <= source_seqnum %d | was false", 
//						tcb.src_port, tcb.expected_acknum, s.tcpHeader.acknum, tcb.src_seqnum); //TODO Remove print
//			}
		}
		else if (tcb.state.equals(ConnectionState.LAST_ACK)) {
//			if (tcb.expected_acknum <= s.tcpHeader.acknum && s.tcpHeader.acknum <= tcb.src_seqnum) {
				System.out.printf("RECV_ACK:%d received ack in LAST_ACK state, will move to CLOSED\n", tcb.src_port); //TODO Remove print
				tcb.state = ConnectionState.CLOSED;
				return true;
//			}
//			else {
//				System.out.printf("RECV_ACK:%d received incorrect ack in LAST_ACK state\n" +
//						"\texpected_acknum %d <= segment_acknum %d <= source_seqnum %d | was false", 
//						tcb.src_port, tcb.expected_acknum, s.tcpHeader.acknum, tcb.src_seqnum); //TODO Remove print
//			}
		}
		else if (tcb.state.equals(ConnectionState.CLOSING)) {
//			if (tcb.expected_acknum <= s.tcpHeader.acknum && s.tcpHeader.acknum <= tcb.src_seqnum) {
				System.out.printf("RECV_ACK:%d received ack in CLOSING state, will move to TIME_WAIT\n", tcb.src_port); //TODO Remove print
				tcb.state = ConnectionState.TIME_WAIT;
				return true;
//			}
//			else {
//				System.out.printf("RECV_ACK:%d received incorrect ack in CLOSING state\n" +
//						"\texpected_acknum %d <= segment_acknum %d <= source_seqnum %d | was false", 
//						tcb.src_port, tcb.expected_acknum, s.tcpHeader.acknum, tcb.src_seqnum); //TODO Remove print
//			}
		}
		/**
		 * Set the expected acknowledgment number to the segment 
		 *  acknowledgment number received, since that will be the 
		 *  the acknowledgment number we at least expect to get
		 */
		return false;
	}
	
	/**
	 * If it is a data packet, set the acknowledgment and
	 *  destination sequence number according to the segment received
	 * 
	 * @param flags: byte variable for the flags of the packet received
	 */
	public boolean recv_data(TcpSegment s) {
		System.out.printf("RECV_DATA:%d Checking DATA Flags...\n", tcb.src_port);//TODO remove print
		if (s.tcpHeader.flags != PSH) {
			return false;
		}
		System.out.printf("RECV_DATA:%d Checking State...\n", tcb.src_port);//TODO remove print
		if (!tcb.state.equals(ConnectionState.ESTABLISHED) && !tcb.state.equals(ConnectionState.FIN_WAIT_1) &&
				!tcb.state.equals(ConnectionState.FIN_WAIT_2)) {
			return false;
		}
		System.out.printf("RECV_DATA:%d Received a data packet of length (arrayLength)%d\n", tcb.src_port, s.data.length);//TODO remove print
		/** Acknum to send should equal the seqnum received, plus the data size */
		tcb.data = s.data;
		tcb.dest_seqnum = (s.tcpHeader.seqnum + s.data.length) % Integer.MAX_VALUE;
		return true;
	}
	
	/**
	 * Receive a FIN packet and based on whether the flags are set 
	 *  and if the client/server is in the correct state to call a close, 
	 *  proceed to a follow up state based on the flag from the packet and
	 *  the current state 
	 * If it is a FIN packet, set the acknowledgment and
	 *  destination sequence number according to the segment received
	 * 
	 * @param flags: byte variable for the flags of the packet received
	 */
	public boolean recv_fin(TcpSegment s) {
		System.out.printf("RECV_FIN:%d Checking FIN Flags...\n", tcb.src_port); //TODO Remove print
		if (s.tcpHeader.flags != (PSH | FIN) && s.tcpHeader.flags != (PSH | FIN | ACK)) {
			return false;
		}
		System.out.printf("RECV_FIN:%d Checking State...\n", tcb.src_port); //TODO Remove print
		if (!tcb.state.equals(ConnectionState.SYN_RCVD) && !tcb.state.equals(ConnectionState.ESTABLISHED) &&
				!tcb.state.equals(ConnectionState.FIN_WAIT_1) && !tcb.state.equals(ConnectionState.FIN_WAIT_2) &&
				!tcb.state.equals(ConnectionState.CLOSE_WAIT)) {
			return false;
		}
		
		System.out.printf("RECV_FIN:%d GOT FIN! STATE: %s\n", tcb.src_port, tcb.state); //TODO Remove print
		
		if (s.tcpHeader.flags == (PSH | FIN)) {
			if (tcb.state.equals(ConnectionState.SYN_RCVD) || tcb.state.equals(ConnectionState.ESTABLISHED)) {
				/** Server receives FIN from Client */
				tcb.state = ConnectionState.CLOSE_WAIT;
			}
			if (tcb.state.equals(ConnectionState.FIN_WAIT_1)) {
				/** Server receives FIN from Client */
				tcb.state = ConnectionState.CLOSING;//TODO should maybe send a fin instead of an ack in this state, so both sides will move to state CLOSING
			}
			if (tcb.state.equals(ConnectionState.FIN_WAIT_2)) {
				/** Clients receives FIN from Server */
				tcb.state = ConnectionState.TIME_WAIT;
			}
		}
		else if (s.tcpHeader.flags == (PSH | FIN | ACK) && tcb.state.equals(ConnectionState.FIN_WAIT_1)) {
			/** Client receives FINACK from Server */
			tcb.state = ConnectionState.TIME_WAIT;
			
		}
		/** Acknum to send should equal the seqnum received, plus the data size 
		 * send ack here, since an ack should be send in any case if this point is reached */
		tcb.dest_seqnum = (s.tcpHeader.seqnum + 1) % Integer.MAX_VALUE;
		send_ack();
		return true;
	}
}
