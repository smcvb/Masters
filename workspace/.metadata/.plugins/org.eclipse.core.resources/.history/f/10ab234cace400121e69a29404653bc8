package nl.vu.cs.cn.test;

import java.io.IOException;

import junit.framework.TestCase;
import nl.vu.cs.cn.ConnectionState;
import nl.vu.cs.cn.IP;
import nl.vu.cs.cn.IP.IpAddress;
import nl.vu.cs.cn.IP.Packet;
import nl.vu.cs.cn.PseudoHeader;
import nl.vu.cs.cn.TCPImplementation;
import nl.vu.cs.cn.TCPImplementation.SocketImplementation;
import nl.vu.cs.cn.TcpHeader;
import nl.vu.cs.cn.TcpSegment;

/**
 * This test performs a check on the proper handling of corrupted sequence numbers
 * - the server accepts a connection
 * - the client connects
 * - the client writes data
 * - the server reads data
 * - retransmissions occur because of multiple positions of corruption 
 *  on the sequence number each corruption happens on a different retransmission
 * - the read data is the same as what was written
 * - both close the connection
 */
public class TcpCorruptSeqNumber extends TestCase {
	
	public static final int ADDR = 130;
	public static final int PORT = 1234;
	public static final int MSG_SIZE = 512;
	private TCPImplementation tcp1;
	private TcpClient tcp2;
	
	/**
	 * This class represents the accepter thread.
	 */
	private class Server implements Runnable {
		
		private SocketImplementation sock;
		private IpAddress ip_addr;
		
		public Server(TCPImplementation tcp) {
			sock = tcp.socket(PORT);
			assertNotNull(sock);
			assertEquals(sock.port, PORT);
			ip_addr = tcp.ip.getLocalAddress();
			assertNotNull(ip_addr);
		}
		
		@Override
		public void run() {
			sock.accept();
			byte[] buf = new byte[10];
			int bytesRead = sock.read(buf, 0, buf.length);
			assertEquals(bytesRead, buf.length);
			for (int i = 0; i < buf.length; i++) {
				assertEquals((byte) i, buf[i]);
			}
			boolean result = sock.close();
			assertTrue(result);
		}	
	}
	
	/**
	 * This class represents the modified TCP stack that the client will use
	 */
	private class TcpClient extends TCPImplementation {
		
		private boolean corruptA,
						corruptB,
						corruptC,
						corruptD;
		
		public TcpClient(int address) throws IOException {
			super(address);
			corruptA = true;
			corruptB = true;
			corruptC = true;
			corruptD = true;
		}
		
		/**
		 * Using the override on the send_data function we can check if all corruptions have been tested
		 */
		@Override
		public int send_data() {
			int bytesSent = 0, bytesRead = 0, dataSize = tcb.packet_data.length, numRetransmission = NUM_RETRANSMISSION;
			byte flags = PSH;
			debugPrint("SEND_DATA:%d Entered send_data() method\n", tcb.src_port);
			if (!tcb.state.equals(ConnectionState.ESTABLISHED) && !tcb.state.equals(ConnectionState.CLOSE_WAIT)) {
				System.err.println("Error: not in state ESTABLISHED or CLOSE_WAIT\n\tcannot send a data packet");
				return -1; // Not in the states ESTABLISHED or CLOSE_WAIT, hence inappropriate method access
			}
			
			while (numRetransmission > 0) {
				debugPrint("SEND_DATA:%d Trying to send data packet... | Try: %d\tSeqnum: %d\tAcknum: %d\n", tcb.src_port, NUM_RETRANSMISSION + 1 - numRetransmission, tcb.src_seqnum, tcb.dest_seqnum);
				bytesSent = send_tcp_packet(tcb.dest_ipaddr, tcb.dest_port, tcb.src_port, tcb.src_seqnum, tcb.dest_seqnum, flags, (short) 1, tcb.packet_data, dataSize);
				if (bytesSent == -1) {
					System.err.println("Error: sending data packet failed");
					return -1;
				}
				else if (numRetransmission == NUM_RETRANSMISSION) {
					tcb.expected_acknum = (tcb.src_seqnum + bytesSent - 20) % Integer.MAX_VALUE; // Expected acknum should equal what we want them to acknowledge
				}
				debugPrint("SEND_DATA:%d Sending data packet was successful\n\tVariables: SourceSeqnum: %d\tExpectedAcknum: %d\nSEND_DATA:%d Wait for following ACK packet...", tcb.src_port, tcb.src_seqnum, tcb.expected_acknum, tcb.src_port);
				
				bytesRead = recv_tcp_packet(true); // Receiving the acknowledgment that the data has arrived
				if (bytesRead > 0 && received_all_acks()) {
					debugPrint("SEND_DATA:%d Receiving ACK was successful | State: %s\n", tcb.src_port, tcb.state);
					
					if (corruptA || corruptB || corruptC || corruptD) {
						fail();
					}
					
					return bytesSent;
				}
				debugPrint("SEND_DATA:%d Receiving ACK to data packet was unsuccessful\n\tVariables: Bytes Read: %d | SourceSeqnum %d == ExpectedAcknum %d\n", tcb.src_port, bytesRead, tcb.src_seqnum, tcb.expected_acknum);
				numRetransmission--;
			}
			
			System.err.println("Error:sending data packet failed ten times");
			return -1;
		}
		
		/**
		 * Using the override on the send_tcp_packet function we can apply the different ways of corruption
		 */
		@Override
		public int send_tcp_packet(IpAddress dest_ipaddr, short dest_port, short src_port, int seqnum, int acknum, byte flags, short window_size, byte[] data, int data_size) {
			int bytesSent;
			short checksum = 0, urg_pointer = 0;
			byte data_offset = 0x05;
			
			if (!corruptC && corruptD && data.length > 0) {
				seqnum += 50;
				corruptD = false;
			}
			
			if (!corruptB && corruptC && data.length > 0) {
				seqnum -= 50;
				corruptC = false;
			}
			
			TcpHeader tcpHead = new TcpHeader(src_port, dest_port, seqnum, acknum, data_offset, flags, window_size, checksum, urg_pointer);
			TcpSegment tcpSeg = new TcpSegment(tcpHead, data);
			PseudoHeader ph = new PseudoHeader(ip.getLocalAddress(), dest_ipaddr, (byte) 0, (byte) IP.TCP_PROTOCOL, tcpSeg.length());
			checksum = tcpSeg.computeChecksum(ph);
			tcpSeg.setChecksum(checksum);
			
			if (!corruptA && corruptB && data.length > 0) {
				seqnum += 50;
				tcpHead.seqnum = seqnum;
				corruptB = false;
			}
			
			if (corruptA && data.length > 0) {
				seqnum -= 50;
				tcpHead.seqnum = seqnum;
				corruptA = false;
			}
			
			debugPrint("SND_TCP_PAC:%d Computed Checksum: %d\n", tcb.src_port, checksum);
			
			Packet p = null;
			try {
				p = new Packet(dest_ipaddr.getAddress(), IP.TCP_PROTOCOL, 2, tcpSeg.getByteArray(), tcpSeg.length());
			} catch (IOException e) {
				System.err.println("Error: failed creating a packet");
				return -1;
			}
			
			try {
				debugPrint("SND_TCP_PAC:%d Trying to send a packet... | State: %s\n", tcb.src_port, tcb.state);
				bytesSent = ip.ip_send(p);
				debugPrint("SND_TCP_PAC:%d Sending the packet was successful | BytesSent: %d (datalength + tcpheader)\tState: %s\n", tcb.src_port, bytesSent, tcb.state);
			} catch (IOException e) {
				System.err.println("Error: failed sending a packet");
				return -1;
			}
			return bytesSent;
		}
	}
	
	/**
	 * This class represents the connecter thread.
	 */
	private class Client implements Runnable {
		
		private SocketImplementation sock;
		private IpAddress ip_addr;
		private IpAddress dst_addr;
		
		public Client(TcpClient tcp, IpAddress dst_addr) {
			sock = tcp.socket(PORT - 1);
			assertNotNull(sock);
			assertEquals(sock.port, PORT - 1);
			ip_addr = tcp.ip.getLocalAddress();
			assertNotNull(ip_addr);
			this.dst_addr = dst_addr;
		}
		
		@Override
		public void run() {
			boolean result;
			do {
				result = sock.connect(dst_addr, PORT);
			} while (!result);
			byte[] buf = new byte[10];
			for (int i = 0; i < buf.length; i++) {
				buf[i] = (byte) i;
			}
			int bytesWritten = sock.write(buf, 0, buf.length);
			assertEquals(bytesWritten, buf.length);
			result = sock.close();
			assertTrue(result);
		}
	}
	
	public TcpCorruptSeqNumber(String method) {
		super(method);
	}
	
	/**
	 * This method will be called by the testSuite to start the test
	 */
	public void testCorruptSeqNumber() {
		System.setProperty("PACKET_LOSS", "0");
		System.setProperty("PACKET_CORRUPTION", "0");
		try {
			tcp1 = new TCPImplementation(ADDR);
			tcp2 = new TcpClient(ADDR + 1);
		} catch (IOException e) {
			fail();
		}
		Server s = new Server(tcp1);
		Client c = new Client(tcp2, tcp1.ip.getLocalAddress());
		assertNotNull(s);
		assertNotNull(c);
		Thread server = new Thread(s);
		Thread client = new Thread(c);
		server.start();
		client.start();
		// use a timeout to avoid infinite loops of code and fail the test if such timeout is reached
		try {
			client.join(15000);
			server.join(1);
			System.out.flush();
		} catch (InterruptedException e) {
			fail();
		}
	}
}
