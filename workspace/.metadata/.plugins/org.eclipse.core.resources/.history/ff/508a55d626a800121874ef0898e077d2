package nl.vu.cs.cn;

import java.io.IOException;
import java.nio.ByteBuffer;
import java.nio.ByteOrder;
import java.util.Random;

import nl.vu.cs.cn.IP.IpAddress;
import nl.vu.cs.cn.IP.Packet;

/**
 * @author Steven van Beelen, 1821806
 * 
 * This class represents a TCP stack. It should be built on top of the IP stack
 * 	which is bound to a given IP address.
 */
public class TCP {
	
	public static final byte 	FIN 				= 0x01, /** The FIN(finish) byte flag */
								SYN 				= 0x02, /** The SYN(synchornize) byte flag */
								PSH 				= 0x08, /** The PSH(push) byte flag */
								ACK 				= 0x10; /** The ACK(acknowledge) byte flag */
	public static final int 	TIMEOUT 			= 60, 	/** Timeout for receiving an acknowledgement in seconds */
								NUM_RETRANSMISSION 	= 10; 	/** Number of times a send may be resend in case of error */
	
	private IP ip;		/** The underlying IP stack for this TCP stack. */
	private TCB tcb;	/** The Transmission Control Block for this TCP stack. */
	
	
	/****************************************************************************************
	 * 								Connecting/Socket Class/Methods 						*
	 ****************************************************************************************/
	
    /**
     * This class represents a TCP socket.
     */
	public class Socket {
		
		private static final int DEFAULT_PORT = 12345;	/** The default port number used for client TCP stacks */
		
		public int port;

		/**
		 * Construct a client socket.
		 */
		private Socket() {
			port = DEFAULT_PORT;
		}
		
    	/**
    	 * Construct a server socket bound to the given local port.
    	 *
    	 * @param port the local port to use
    	 */
		private Socket(int port) {
			this.port = port;
		}
		
		/**
		 * Connect this socket to the specified destination and port.
		 * The client will perform a connect request
         *
         * @param dest_ipaddr the destination to connect to
         * @param port the port to connect to
         * @return true if the connect succeeded.
         */
	 	public boolean connect(IpAddress dest_ipaddr, int port) {
	 		int bytesSent = 0;
	 		if(tcb.state != ConnectionState.CLOSED) { /** there is already a connection, hence stop connect call */
	 			return false;
	 		}
	 		
	 		tcb.src_port 		= (short)this.port;
	 		tcb.dest_ipaddr 	= dest_ipaddr;
	 		tcb.dest_port 		= (short)port;
	 		tcb.state 			= ConnectionState.SYN_SENT;
	 		bytesSent 			= send_syn(); /** 1 step of 3-way-handshake */
	 		if(bytesSent == -1){
	 			tcb.state 		= ConnectionState.CLOSED;
	 			return false;	/** Connecting failed */
	 		}
	 		return true;		/** Connection established */
        }
		
        /**
         * Accept a connection on this socket.
         * This call blocks until a connection is made.
         * The server will wait in the accept method for a connect request
         */
	 	public void accept(){
	 		int bytesSent = 0;
	 		if(tcb.state != ConnectionState.CLOSED) { /** there is already a connection, hence stop connect call */
	 			return;
	 		}
	 		tcb.state = ConnectionState.LISTEN;
	 		while(tcb.state != ConnectionState.ESTABLISHED) {
	 			recv_packet(false); /** Call blocks on receive */
	 			if(tcb.state == ConnectionState.SYN_RCVD) {
	 				bytesSent = send_syn();/** 2 step of 3-way-handshake */
	 				if(bytesSent == -1) {
	 					tcb.state = ConnectionState.CLOSED;
	 					return;/** Connecting failed || maybe inappropriate to cancel server in faulty syn sending scenario */
	 				} else {
	 					tcb.state = ConnectionState.ESTABLISHED;
	 				}
	 			}
	 		}
        }
		
        /**
         * Reads bytes from the socket into the buffer.
         * This call is not required to return maxlen bytes
         * every time it returns.
         *
         * @param buf the buffer to read into
         * @param offset the offset to begin reading data into
         * @param maxlen the maximum number of bytes to read
         * @return the number of bytes read, or -1 if an error occurs.
         */
	 	public int read(byte[] buf, int offset, int maxlen) {
	 		int bytesRead = 0;
	 		
	 		if (tcb.state != ConnectionState.ESTABLISHED && tcb.state != ConnectionState.FIN_WAIT_1 &&
	 				tcb.state != ConnectionState.FIN_WAIT_2 && tcb.state != ConnectionState.CLOSING &&
	 				tcb.state != ConnectionState.CLOSE_WAIT && tcb.state != ConnectionState.LAST_ACK &&
	 				tcb.state != ConnectionState.CLOSED) {
	 	        return -1;/** If none of these hold, we will not accept data read */
	 		}
	 		
	    	recv_packet(true); /** true means waitingReceive, as required by the assignment */
	    	bytesRead = tcb.data.length;
	    	if(bytesRead == -1) {
	    		return -1;
	    	}
	    	
	    	try{
	    		pass_over_data(buf, offset, maxlen);
	    	} catch(Exception e){
	    		e.printStackTrace();
	    	}
	 		
	 		return bytesRead;
		}

		/**
	 	 * The method copying the received data into the buffer
	 	 * 
	 	 * @param buf: the buffer to read into
	 	 * @param offset: the offset to begin reading data into
	 	 * @param maxlen: the maximum number of bytes to read
	 	 */
	 	private void pass_over_data(byte[] buf, int offset, int maxlen) throws NullPointerException, ArrayStoreException, IndexOutOfBoundsException{
	 		byte[] 	data 			= tcb.data;
	 		int 	len 			= maxlen,
	 				dataLeft 		= data.length,
	 				bytesWritten	= 0;
	 		
	 		while(dataLeft != 0) {
	 			len = Math.min(maxlen, dataLeft);
	 			System.arraycopy(data, bytesWritten, buf, offset, len);
	 			dataLeft -= len;
	 			bytesWritten += len;
	 			offset += len;
	 		}
	 	}
		
        /**
         * Writes to the socket from the buffer.
         *
         * @param buf the buffer to
         * @param offset the offset to begin writing data from
         * @param len the number of bytes to write
         * @return the number of bytes written or -1 if an error occurs.
         */
	 	public int write(byte[] buf, int offset, int len) {
        	byte[] 	data;
        	int 	dataSize	= 0,
        			bytesSent 	= 0,
        			bytesLeft 	= len;
        	
        	if(tcb.state != ConnectionState.ESTABLISHED) {
        		return -1;/** Not in a state to transmite data */
        	}
			
			/** Looping through the array until all packets have been send */
			while(bytesLeft > 0) {
				dataSize 	= Math.min(bytesLeft, TCB.BUF_SIZE);
				data 		= new byte[dataSize];
				System.arraycopy(buf, offset, data, 0, dataSize);
				bytesSent 	= send_data(data);	/** The actual sending from the socket to the tcp stack */
				if(bytesSent >= 0){
					bytesLeft 	-= bytesSent;
					offset 		+= bytesSent;
				} else {
					data = null;
				}
        	}
	        
        	if(bytesLeft == len) {
        		return -1;
        	}
        	
			return len - bytesLeft;
		}
		
        /**
         * Closes the connection for this socket.
         * Blocks until the connection is closed.
         *
         * @return true unless no connection was open.
         */
	 	public boolean close() {
	 		int bytesSent = 0;
	 		bytesSent = send_fin();
	 		if(bytesSent == -1){
	 			return false;
	 		}
			return true;
		}
	}
    	
	/**
	* Constructs a TCP stack for the given virtual address.
	* The virtual address for this TCP stack is then
	* 192.168.1.address.
	*
	* @param address The last octet of the virtual IP address 1-254.
	* @throws IOException if the IP stack fails to initialize.
	*/
	public TCP(int address) throws IOException {
		ip 				= new IP(address);
		tcb 			= new TCB(ip.getLocalAddress());
		Random random 	= new Random();
		tcb.src_seqnum 	= random.nextInt(250);
	}
	
	/**
	* @return a new socket for this stack
	*/
	public Socket socket() {
		return new Socket();
	}
	
	/**
	* @return a new server socket for this stack bound to the given port
	* @param port the port to bind the socket to.
	*/
	public Socket socket(int port) {
		return new Socket(port);
	}
	
	
	/****************************************************************************************
	 * 									Sending Methods			 							*
	 ****************************************************************************************/
	
	/**
	 * Method to send a 'synchronize'(SYN) request message to the destination port
	 * 
	 * @return the number of bytes sent as an integer
	 */
	private int send_syn(){
		int 	bytesSent 			= 0,
				numRetransmission 	= NUM_RETRANSMISSION;
		byte 	flags 				= (byte)0;
		
		if(tcb.state == ConnectionState.LISTEN){			/** Server socket which already received a SYN sends SYNACK back */
			flags = PSH | SYN | ACK;
		} else if(tcb.state == ConnectionState.SYN_SENT){	/** Client socket sending the first SYN for the connection */
			flags = PSH | SYN;
		} else {											/** Not in the states LISTEN or CLOSED, hence inappropriate method access */
			return -1;
		}
		
		while(numRetransmission > 0){
			bytesSent = send_tcp_packet(tcb.dest_ipaddr, tcb.dest_port, tcb.src_port, tcb.src_seqnum, tcb.acknum, flags, (short)0, new byte[0], 0);
			if(bytesSent == -1) {
				return -1;
			}
			if(recv_packet(true) > 0) {						/** Receiving the synchornize acknowledgement for the SYN request */
				return bytesSent;
			}
			numRetransmission--;
		}
		return -1;											/** SYN sending failed */
	}
	
	/**
	 * Method to send a data message to the destination port
	 * 
	 * @param data: the data to be send in a byte array
	 * @return the number of bytes sent as an integer
	 */
	private int send_data(byte[] data){
		int 	bytesSent 			= 0,
				dataSize 			= data.length,
				numRetransmission 	= NUM_RETRANSMISSION;
		byte 	flags 				= PSH | ACK;
		
		while(numRetransmission > 0){
			bytesSent = send_tcp_packet(tcb.dest_ipaddr, tcb.dest_port, tcb.src_port, tcb.src_seqnum, tcb.acknum, flags, (short)0, data, dataSize);
			if(bytesSent == -1){
				return -1;
			} else {
				tcb.expected_acknum = tcb.src_seqnum + bytesSent;
			}
			
			if(recv_packet(true) > 0) {	/** Receiving the acknowledgement that the data has arrived */
				return bytesSent;
			}
			numRetransmission--;
		}
		return -1;						/** Data sending failed */
	}
	
	/**
	 * Method to send an 'acknowledgement'(ACK) message to the destination port
	 * 
	 * @return the number of bytes sent as an integer
	 */
	private int send_ack(){
		byte flags = PSH | ACK;
		return send_tcp_packet(tcb.dest_ipaddr, tcb.dest_port, tcb.src_port, tcb.src_seqnum, tcb.acknum, flags, (short)0, new byte[0], 0);
	}
	
	/**
	 * Method to send a 'finish'(FIN) request message to the destination port
	 * 
	 * @return the number of bytes sent as an integer
	 */
	private int send_fin(){
		int 	bytesSent 			= 0,
				numRetransmission 	= NUM_RETRANSMISSION;
		byte 	flags 				= (byte)0;
		
		if(tcb.state == ConnectionState.SYN_RCVD || tcb.state == ConnectionState.ESTABLISHED){/** Client shut down */
			flags = PSH | FIN;
		} else if(tcb.state == ConnectionState.CLOSE_WAIT){
			flags = PSH | FIN | ACK;
		}
		
		while(numRetransmission > 0){
			bytesSent = send_tcp_packet(tcb.dest_ipaddr, tcb.dest_port, tcb.src_port, tcb.src_seqnum, tcb.acknum, flags, (short)0, new byte[0], 0);
			if(bytesSent == -1) {
				return -1;
			}
			if(recv_packet(true) > 0) {	/** Receiving the acknowledgement to finish the connection */
				return bytesSent;
			}
			numRetransmission--;
		}
		return -1;						/** FIN sending failed */
	}
	
	/**
	 * Base sending method of tcp packets
	 * 
	 * @param dest_ipaddr: The destination IP address to send to
	 * @param src_port: The port from which the packet will originate
	 * @param dest_port: The port to which the packet will be send
	 * @param seqnum: The sequence number for this packet
	 * @param acknum: The acknowlegde number for this packet
	 * @param flags: The flags for this packet
	 * @param window_size: The windows size for this packet (not used)
	 * @param data: The data which this packet will send
	 * @param data_size: The size of the data in this packet
	 * @return The number of bytes send as an integer
	 */
	private int send_tcp_packet(IpAddress dest_ipaddr, short src_port, short dest_port, int seqnum, int acknum, byte flags, short window_size, byte[] data, int data_size){
        int 	bytesSent;
        short 	checksum 	= 0;
        short 	urg_pointer = 0;
        byte 	data_offset = 0x20;/** The data starts after 20 bytes permenantly, since we do not use any options */
        
        TcpHeader tcpHead 	= new TcpHeader(src_port, dest_port, seqnum, acknum, data_offset, flags, window_size, checksum, urg_pointer);
        tcpHead.data_offset = (byte)(tcpHead.length());
        TcpSegment tcpSeg 	= new TcpSegment(tcpHead, data);
        PseudoHeader ph		= new PseudoHeader(ip.getLocalAddress(), dest_ipaddr, (short)0, (short)IP.TCP_PROTOCOL, tcpSeg.length());
        tcpSeg.setChecksum(tcpSeg.computeChecksum(ph));
        
        Packet p = null;
		try {
			p = new Packet(dest_ipaddr.getAddress(), IP.TCP_PROTOCOL, 2, tcpSeg.getByteArray(), tcpSeg.length());
		} catch (IOException e1) {
			e1.printStackTrace();
		}
		
		try{
			bytesSent = ip.ip_send(p);
        } catch(IOException e){
        	e.printStackTrace();
        	bytesSent = -1;
        }
		
        return bytesSent;
    }
    
	
	/****************************************************************************************
	 * 									Receiving Methods 									*
	 ****************************************************************************************/
	
	/**
	 * Global method for receiving any type of packet
	 * 
	 * @param waitingReceive: boolean used to know if the caller
	 * 	is willing to wait for its ip_receive yes or no
	 * @return the number of bytes read as an integer
	 */
	private int recv_packet(boolean waitingReceive){
		/** values will be initialized by recv_tcp_packet method */
		IP.IpAddress 	dest_ipaddr = IP.IpAddress.getAddress(0);
		short 			src_port = 0,
						dest_port = 0,
						window_size = 0;
		int 			bytesRead = 0,
						seqnum = 0,
						acknum = 0,
						data_size = 0;
		byte			flags = 0;
		byte[]			data = new byte[TCB.BUF_SIZE];
		
		bytesRead = recv_tcp_packet(dest_ipaddr, src_port, dest_port, seqnum, acknum, flags, window_size, data, data_size, waitingReceive);
		
		if(!correct_recvd_packet(dest_ipaddr, src_port, dest_port, seqnum, acknum)){
			return -1;
		}
		
		if(bytesRead != -1){
			if(tcb.src_port == dest_port && tcb.dest_port == src_port){
				recv_syn(dest_ipaddr, src_port, dest_port, seqnum, flags);
				recv_data(data_size, flags, data);
				recv_ack(flags, acknum);
				recv_fin(flags);
				return bytesRead;
			}
		}
		return -1;
	}
	

	
	/**
	 * Checks whether the information send corresponds with the information expected
	 * 
	 * @param dest_ipaddr: The destination IP address to send to
	 * @param src_port: The port from which the packet will originate
	 * @param dest_port: The port to which the packet will be send
	 * @param seqnum: The sequence number for this packet
	 * @param acknum: The acknowlegde number for this packet
	 * @return True if it was a correct packet | False if it was an incorrect packet
	 */
	private boolean correct_recvd_packet(IP.IpAddress dest_ipaddr, short src_port, short dest_port, int seqnum, int acknum){
		if(tcb.dest_ipaddr == null) {
			tcb.dest_ipaddr = dest_ipaddr;
		}
		if(tcb.src_port == 0) {
			tcb.dest_port = src_port;
		}
		if(tcb.dest_ipaddr == dest_ipaddr && tcb.src_port == dest_port && tcb.dest_port == src_port && tcb.dest_seqnum == seqnum
				&& tcb.expected_acknum == acknum) {
			return true;
		}
		return false;
	}
	
	/**
	 * Receive a syn packet and based on the connection state
	 *   Inherently, receiving the syn is the second step of the 
	 *   3-way-handshake
	 * 
	 * @param dest_ipaddr
	 */
	private void recv_syn(IP.IpAddress dest_ipaddr, short src_port, short dest_port, int seqnum, byte flags){
		if(tcb.state == ConnectionState.LISTEN && flags == (PSH | SYN)) {/** Servers SYN receive */
			tcb.state = ConnectionState.SYN_RCVD;
		} else if(tcb.state == ConnectionState.SYN_SENT && flags == (PSH | SYN | ACK)) {/** Clients SYN receive */
			send_ack();/** Step 3 of 3-way-handshake */
			tcb.state = ConnectionState.ESTABLISHED;
		}
	}
	
	/**
	 * 
	 * @param flags
	 */
	private void recv_data(int data_size, byte flags, byte[] data){
		if(flags != (PSH | ACK)) {
			return;
		}
		if(tcb.state != ConnectionState.ESTABLISHED || tcb.state != ConnectionState.FIN_WAIT_1 || tcb.state != ConnectionState.FIN_WAIT_2) {
			return;
		}
	}
	
	/**
	 * 
	 * @param flags
	 */
	private void recv_fin(byte flags){
		if(flags == (PSH | FIN)){/** Server receives FIN from Client */
			
		} else if(flags == (PSH | FIN | ACK)){/** Client receives FINACK from Server */
			
		}
		if(flags != (PSH | FIN) || flags != (PSH | FIN | ACK)) {
			return;
		}
		if(tcb.state != ConnectionState.ESTABLISHED || tcb.state != ConnectionState.FIN_WAIT_1 || tcb.state != ConnectionState.FIN_WAIT_2
				|| tcb.state != ConnectionState.CLOSE_WAIT || tcb.state != ConnectionState.CLOSING || tcb.state != ConnectionState.LAST_ACK){
			return;
		}
		tcb.state = ConnectionState.FIN_WAIT_2;
	}
	
	/**
	 * 
	 * @param flags
	 * @param acknum
	 */
	private void recv_ack(byte flags, int acknum){
		if(flags != (PSH | ACK))
			return;
		//if(/*not in correct states to call this method*/)
		//	return;
		if (acknum == tcb.expected_acknum){
	        tcb.src_seqnum = acknum;
		}
	}
	
    /**
     * Base method to receive the ip packets
     * 
     * @param dest_ipaddr: empty IpAddress variable to store the destination IP address in
     * @param src_port: empty short variable to store the source port in
     * @param dest_port: empty short variable to store the destination port in
     * @param seqnum: empty integer variable to store the sequence number in
     * @param acknum: empty integer variable to store the acknowledgement number in
     * @param flags: empty bytevariable to store the flags in
     * @param window_size: short empty variable to store the window size in
     * @param data: empty byte array to store the data in
     * @param data_size: empty integer variable to store the data size in
     * @param waitingReceive: boolean dictating the type of receive method used
     * @return the number of bytes sent as an integer
     */
    private int recv_tcp_packet(IpAddress dest_ipaddr, short src_port, short dest_port, int seqnum, int acknum, byte flags, short window_size, byte[] data, int data_size, boolean waitingReceive){
    	byte 			data_offset = (byte)0;
    	short 			checksum 	= (short)0;
        short 			urg_pointer = (short)0;
    	TcpSegment 		s 			= new TcpSegment();
    	Packet 			p 			= new Packet(0, 0, 0, new byte[0], 0);/** Initial empty packet to store incoming packet */
    	PseudoHeader 	ph 			= new PseudoHeader();
    	
    	try {
    		how_to_receive(p, waitingReceive);
    	} catch(Exception e){
    		e.printStackTrace();
    		return -1;
    	}

    	if(p.protocol != IP.TCP_PROTOCOL) {
    		return -1;
    	}
    	
    	s = decodePacket(p, src_port, dest_port, seqnum, acknum, data_offset, flags, window_size, checksum, urg_pointer, data);/** Writes all packet info to the tcp segment, thus to all parameters given to this method */
    	ph 	= new PseudoHeader(IP.IpAddress.getAddress(p.source), IP.IpAddress.getAddress(p.destination), (short)0, (short)IP.TCP_PROTOCOL, s.length());
    	
    	if(!s.validateChecksum(ph)) {
    		return -1;
    	}
    	
    	return s.length();
	}
    
    /**
	 * Switching method between the ip_receive_timeout method
	 * 	and the ip_receive method
	 * 
	 * @param p: The packet which will store the received information
	 * @param waitingReceive: the boolean which dictates if
	 * 	ip_receive_timeout or ip_receive will be used
     * @throws InterruptedException 
     * @throws IOException 
	 */
	private void how_to_receive(Packet p, boolean waitingReceive) throws IOException, InterruptedException{
		if(waitingReceive){
			ip.ip_receive_timeout(p, TIMEOUT);
		} else {
			ip.ip_receive(p);
		}
	}
    
    /**
     * Method which decodes an incoming packet into a 
     * 	TCP segment
     * 
     * @param p: the received packet
     * @param src_port: empty short variable to store incoming source port in
     * @param dest_port: empty short variable to store incoming destination port in
     * @param seqnum: empty short integer to store incoming sequence number in
     * @param acknum: empty short integer to store incoming acknowledgement number in
     * @param data_offset: empty byte variable to store incoming data offset in
     * @param flags: empty byte variable to store incoming flags in
     * @param window_size: empty short variable to store incoming window size in
     * @param checksum: empty short variable to store incoming checksum in
     * @param urg_pointer: empty short variable to store incoming urgent pointer in
     * @param data: empty byte array to store incoming data in
     * @return a TCP segment containing all the relevant data from the packet
     */
	private TcpSegment decodePacket(Packet p, short src_port, short dest_port, int seqnum, int acknum, byte data_offset, byte flags, short window_size, short checksum, short urg_pointer, byte[] data){
		ByteBuffer shortBuffer 	= ByteBuffer.allocate(2);
		ByteBuffer intBuffer 	= ByteBuffer.allocate(4);
		shortBuffer.order(ByteOrder.BIG_ENDIAN);
		intBuffer.order(ByteOrder.BIG_ENDIAN);
		
		shortBuffer.put(p.data[1]);
		shortBuffer.put(p.data[2]);
		src_port 	= shortBuffer.getShort();
		shortBuffer.put(p.data[3]);
		shortBuffer.put(p.data[4]);
		dest_port 	= shortBuffer.getShort();
		intBuffer.put(p.data[5]);
		intBuffer.put(p.data[6]);
		intBuffer.put(p.data[7]);
		intBuffer.put(p.data[8]);
		seqnum 		= intBuffer.getInt();
		intBuffer.put(p.data[9]);
		intBuffer.put(p.data[10]);
		intBuffer.put(p.data[11]);
		intBuffer.put(p.data[12]);
		acknum		= intBuffer.getInt();
		data_offset = p.data[13];
		flags 		= p.data[14];
		shortBuffer.put(p.data[15]);
		shortBuffer.put(p.data[16]);
        window_size 	= shortBuffer.getShort();
        shortBuffer.put(p.data[17]);
		shortBuffer.put(p.data[18]);
        checksum 	= shortBuffer.getShort();
        shortBuffer.put(p.data[19]);
		shortBuffer.put(p.data[20]);
        urg_pointer = shortBuffer.getShort();
        data		= new byte[p.length - 20];
        System.arraycopy(p.data, 21, data, 0, p.length);
		
		return new TcpSegment(new TcpHeader(src_port, dest_port, seqnum, acknum, data_offset, flags, window_size, checksum, urg_pointer), data);
	}
}