import java.io.IOException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Map.Entry;
import java.util.Random;

import org.apache.hadoop.conf.Configuration;
import org.apache.hadoop.conf.Configured;
import org.apache.hadoop.fs.Path;
import org.apache.hadoop.io.LongWritable;
import org.apache.hadoop.io.Text;
import org.apache.hadoop.util.Tool;
import org.apache.hadoop.util.ToolRunner;
import org.apache.hama.HamaConfiguration;
import org.apache.hama.bsp.BSP;
import org.apache.hama.bsp.BSPJob;
import org.apache.hama.bsp.BSPPeer;
import org.apache.hama.bsp.TextInputFormat;
import org.apache.hama.bsp.TextOutputFormat;
import org.apache.hama.bsp.sync.SyncException;

import types.Point;
import types.PointMessage;

/**
 * Hama program to run the k-means algorithm
 * @author stevenb
 * @date 05-08-2013
 */
public class KMeans extends Configured implements Tool {
	
	public static final float CONVERGENCE_POINT = 0.01f;
	public static final String POINT = "POINT",
			OUTLIER = "OUTLIER";
	
	public static class KMeansBSP extends BSP<LongWritable, Text, Point, Text, PointMessage> {
		
		private boolean converged;
		private int kmeans, round, iterations;
		private Point mean;
		private Point[] outliers;
		private ArrayList<Point> points;
		private HashMap<String, Point> clusters;
		
		@Override
		public void setup(BSPPeer<LongWritable, Text, Point, Text, PointMessage> peer) throws IOException { //initialize
			converged = false;
			kmeans = peer.getNumPeers();
			round = 0;
			iterations = peer.getConfiguration().getInt("iterations", 0);
			mean = null;
			outliers = new Point[(kmeans - 1) * kmeans]; // The total number of outliers in the system is kmeans - 1 times the number of peers
			points = new ArrayList<Point>();
			clusters = new HashMap<String, Point>(kmeans);
			
			System.out.printf("SETUP: kmeans = %d\tround = %d\titerations = %d\n", kmeans, round, iterations); // TODO REMOVE
		}
		
		@Override
		/**
		 * The KMeans Clustering algorithm
		 */
		public void bsp(BSPPeer<LongWritable, Text, Point, Text, PointMessage> peer) throws IOException, InterruptedException, SyncException {
			//if (masterTask(peer)) {
				initialize(peer);
			//}
			
			while (!converged && round < iterations) {
				peer.sync();
				converged = receiveMessages(peer);
				if (converged) {
					break;
				}
				if (points.isEmpty()) { // TODO REMOVE
					System.out.printf("BSP: Round %d | %s is an empty cluster\n", round, peer.getPeerName()); // TODO REMOVE
				} // TODO REMOVE
				assignPoints(peer);
				recalculateMean(peer);
				//setOutliers(peer);
				peer.sync();
				round++;
			}
			
			System.out.printf("BSP: Did %d rounds and converged:%b\n", round, converged); // TODO REMOVE
		}
		
		/**
		 * Check whether this peer is the master task.
		 * Being the master task corresponds to having the unique
		 *  peer index of zero.
		 * @param peer: a BSPPeer object containing all the information about 
		 * 	this BSPPeer task
		 * @return true incase this peer is the master task and false
		 *  if it is not.
		 */
		private boolean masterTask(BSPPeer<LongWritable, Text, Point, Text, PointMessage> peer) {
			System.out.printf("%s MASTER_TASK: PeerIndex = %d\n", peer.getPeerName(), peer.getPeerIndex()); // TODO REMOVE
			if (peer.getPeerIndex() == 0) {
				return true;
			}
			return false;
		}
		
		/**
		 * The first round of KMeans, hence first need to initialize
		 *  all the point to a cluster.
		 * Points are assigned randomly to a cluster (Random Partitioning)
		 *  within this program.
		 * @param peer: a BSPPeer object containing all the information about 
		 * 	this BSPPeer task.
		 * @throws IOException from the readNext() and send() methods.
		 */
		private void initialize(BSPPeer<LongWritable, Text, Point, Text, PointMessage> peer) throws IOException {
			System.out.printf("%s INITIALIZE\n", peer.getPeerName()); // TODO REMOVE
			int count = 0; // TODO REMOVE
			
			LongWritable key = new LongWritable();
			Text value = new Text();
			String[] lines = null;
			
			while (peer.readNext(key, value)) {
				count++;
				lines = value.toString().split("\n");
				for (int i = 0; i < lines.length; i++) {
					Random random = new Random();
					int clusterIndex = random.nextInt(kmeans);
					Point point = new Point(lines[i]);
					PointMessage m = new PointMessage(POINT, point);
					peer.send(peer.getPeerName(clusterIndex), m);
				}
				System.out.printf("%s INITIALIZE: Initialized new line\n\t%s\n", peer.getPeerName(), value); // TODO REMOVE
			}
			System.out.printf("%s INITIALIZE: has read %d lines/points\n", peer.getPeerName(), count); // TODO REMOVE
		}
		
		/**
		 * Receive all the messages send by other peers at this peer.
		 * Depending on the tag contained in the PointMessage object,
		 *  one can see whether it is a new point or a cluster centroid
		 *  message.
		 * @param peer: a BSPPeer object containing all the information about 
		 * 	this BSPPeer task.
		 * @return true or false depending on whether the algorithm converged
		 * @throws IOException from the getCurrentMessage() method.
		 */
		private boolean receiveMessages(BSPPeer<LongWritable, Text, Point, Text, PointMessage> peer) throws IOException {
			System.out.printf("%s RECEIVE_MESSAGES\n", peer.getPeerName()); // TODO REMOVE
			int totalPointsReceived = peer.getNumCurrentMessages();
			HashMap<String, Point> newClusters = new HashMap<String, Point>(kmeans);
			
			for (int i = 0; i < totalPointsReceived; i++) {
				PointMessage message = peer.getCurrentMessage();
				String tag = message.getTag();
				System.out.printf("Round %d | %s received %s\n", round, peer.getPeerName(), tag); // TODO REMOVE
				if (tag.equals(POINT)) { // Received a Point message
					points.add(message.getPoint());
				} else if (tag.equals(OUTLIER)) { // Received an Outlier message 
					System.out.printf("Round %d | Found OUTLIER // Shouldn't happen!\n", round);
				} else { // Probably a Cluster mean
					newClusters.put(tag, message.getPoint());
				}
			}
			
			return checkConvergence(newClusters);
		}
		
		/**
		 * Check whether the algorithm has converged, 
		 *  compared to the previous cluster centroid and
		 *  the current cluster centroids.
		 * @param newClusters: A HashMap object containing
		 *  the new cluster_name/mean combinations.
		 * @return true in case the algorithm, false
		 *  in case it did not.
		 */
		private boolean checkConvergence(HashMap<String, Point> newClusters) {
			System.out.printf("CONVERGENCE: Started to check for convergence...\n"); // TODO REMOVE
			if(clusters.isEmpty()){  // if this is the first iteration/checkConvergence()  method call, then its length will be zero
				System.out.printf("CONVERGENCE: no previous cluster, so false\n"); // TODO REMOVE
				setNewClusters(newClusters);
				return false;
			} else if(clusters.size() != newClusters.size()){ // if the sizes do not equal, one or both hold one or more empty clusters; hence no convergence
				System.out.printf("CONVERGENCE: empty cluster in previous set or current set, hence false\n"); // TODO REMOVE
				setNewClusters(newClusters);
				return false;
			}
			
			for (Entry<String, Point> cluster : clusters.entrySet()) {
				Point oldMean = cluster.getValue();
				Point newMean = newClusters.get(cluster.getKey());
				if (oldMean.compareTo(newMean, CONVERGENCE_POINT) != 0) {
					setNewClusters(newClusters);
					return false;
				}
			}
			setNewClusters(newClusters);
			return true;
		}
		
		/**
		 * Set the newly found clusters as
		 *  the current clusters
		 * @param newClusters: A HashMap containing the new clusters
		 */
		private void setNewClusters(HashMap<String, Point> newClusters) {
			System.out.printf("SET_NEW_CLUSTERS\n"); // TODO REMOVE
			for(Entry<String, Point> entry : newClusters.entrySet()){
				clusters.remove(entry.getKey());
				clusters.put(entry.getKey(), entry.getValue());
			}
		}
		
		/**
		 * Check whether a point contained in this cluster is 
		 *  closer to another clusters its mean. If so, assign 
		 *  that point to that clusters and remove it from your own.
		 * @param peer: a BSPPeer object containing all the information about 
		 * 	this BSPPeer task.
		 * @throws IOException from the send() method
		 */
		private void assignPoints(BSPPeer<LongWritable, Text, Point, Text, PointMessage> peer) throws IOException {
			System.out.printf("%s ASSIGN_POINTS\n", peer.getPeerName()); // TODO REMOVE
			String name = peer.getPeerName();
			double dist = 0.0, minDist = Double.MAX_VALUE;
			for (int i = 0; i < points.size(); i++) {
				String[] clusterNames = peer.getAllPeerNames();
				for (String clusterName : clusterNames) {
					dist = points.get(i).calculateDistance(clusters.get(clusterName));
					if (dist < minDist) {
						minDist = dist;
						name = clusterName;
					}
				}
				
				if (!name.equals(peer.getPeerName())) { // If the point did not stay in my cluster, send a message to the correct peer 
					PointMessage m = new PointMessage(POINT, points.remove(i));
					System.out.printf("%s ASSIGN_POINTS: Going to send %s to %s\n", peer.getPeerName(), m.toString(), name); // TODO REMOVE
					peer.send(name, m);
				}
			}
		}
		
		/**
		 * Recalculate the centroid of this cluster.
		 * @param peer: a BSPPeer object containing all the information about 
		 * 	this BSPPeer task.
		 * @throws IOException from the broadcastNewMean() method
		 */
		private void recalculateMean(BSPPeer<LongWritable, Text, Point, Text, PointMessage> peer) throws IOException {
			System.out.printf("%s RECALCULATE_MEAN\n", peer.getPeerName()); // TODO REMOVE
			int i = 0;
			Point newMean = new Point();
			for (Point point : points) {
				if (i == 0) {
					newMean = point;
				} else {
					newMean.add(point);
				}
				i++;
			}
			newMean.divide(i);
			mean = newMean;
			
			broadcastNewMean(peer);
		}
		
		/**
		 * Broadcast the newly calculated centroid of this cluster
		 *  to the other clusters.
		 * @param peer: a BSPPeer object containing all the information about 
		 * 	this BSPPeer task.
		 * @throws IOException from the send() method
		 */
		private void broadcastNewMean(BSPPeer<LongWritable, Text, Point, Text, PointMessage> peer) throws IOException {
			System.out.printf("%s BROADCAST_NEW_MEAN\n", peer.getPeerName()); // TODO REMOVE
			String[] clusterNames = peer.getAllPeerNames();
			for (String clusterName : clusterNames) {
				PointMessage m = new PointMessage(peer.getPeerName(), mean);
				System.out.printf("%s BROADCAST_NEW_MEAN: Going to send %s to %s\n", peer.getPeerName(), m.toString(), clusterName); // TODO REMOVE
				peer.send(clusterName, m);
			}
		}
		
		/**
		 * Set the k - 1 outliers of this cluster, by 
		 *  calculating which points have the largest
		 *  distance to the center 
		 * @param peer: a BSPPeer object containing all the information about 
		 * 	this BSPPeer task.
		 * @throws IOException from the broadcastOutliers() method.
		 */
		private void setOutliers(BSPPeer<LongWritable, Text, Point, Text, PointMessage> peer) throws IOException {
			System.out.printf("%s SET_OUTLIERS\n", peer.getPeerName()); // TODO REMOVE
			Point[] newOutliers = new Point[outliers.length];
			for (Point point : points) {
				boolean gotPosition = false;
				double dist = point.calculateDistance(mean);
				for (int k = 0; k < outliers.length; k++) {
					if (!gotPosition) {
						newOutliers[k] = outliers[k];
						if (newOutliers[k] == null) { // If it is an empty spot, fill directly
							newOutliers[k] = point;
							gotPosition = true;
						} else if (outliers[k].calculateDistance(mean) < dist) {
							newOutliers[k] = point;
							gotPosition = true;
						}
					} else {
						newOutliers[k] = outliers[k - 1];
					}
				}
			}
			outliers = newOutliers;
			broadcastOutliers(peer);
		}
		
		/**
		 * 
		 * @param peer: a BSPPeer object containing all the information about 
		 * 	this BSPPeer task.
		 * @throws IOException from the send() method.
		 */
		private void broadcastOutliers(BSPPeer<LongWritable, Text, Point, Text, PointMessage> peer) throws IOException {
			System.out.printf("%s BROADCAST_OUTLIERS\n", peer.getPeerName()); // TODO REMOVE
			String[] clusterNames = peer.getAllPeerNames();
			for (String clusterName : clusterNames) {
				for (Point outlier : outliers) {
					PointMessage m = new PointMessage(OUTLIER, outlier);
					peer.send(clusterName, m);
				}
			}
		}
		
		@Override
		public void cleanup(BSPPeer<LongWritable, Text, Point, Text, PointMessage> peer) throws IOException { // Close
			for (Point point : points) { // Write the mean - Point pairs out to a file
				peer.write(mean, new Text(point.toString()));
			}
			points.clear(); // Empty memory
		}
	}
	
	/**
	 * Create the job.
	 * @param args: String array of arguments
	 * @param conf: a HamaConfiguration Object for the BSP job
	 * @return a finalized BSPJob Object for this BSP job
	 * @throws IOException for creating the BSP job Object
	 */
	public static BSPJob createJob(HamaConfiguration conf, Path inputPath, Path outputPath, int kmeans) throws IOException {
		BSPJob job = new BSPJob(conf, KMeans.class); // Main settings
		job.setJobName("KMeans Clustering");
		job.setBspClass(KMeansBSP.class);
		job.setNumBspTask(kmeans);
		job.setInputPath(inputPath); // Input settings
		job.setInputFormat(TextInputFormat.class);
		job.setInputKeyClass(LongWritable.class);
		job.setInputValueClass(Text.class);
		job.setOutputPath(outputPath); // Output settings
		job.setOutputFormat(TextOutputFormat.class);
		job.setOutputKeyClass(Point.class);
		job.setOutputValueClass(Text.class);
		
		return job;
	}
	
	/**
	 * Prints out the usages of this program in case the user
	 *  gave incorrect input
	 * @param numArgs: number of arguments in the String array object
	 */
	private int printUsage() {
		System.out.println("usage:\t <input path> <output path> <k mean points> <number of iterations> <[OPTIONAL] add 'combine' to use inmapper combiner>");
		ToolRunner.printGenericCommandUsage(System.out);
		return -1;
	}
	
	@Override
	/**
	 * Runs the main program
	 * 
	 * @param args: String array of arguments given at start 
	 * @return -1 in case of error | 0 in case of success
	 * @throws Exception from the createJob() and the waitForCompletion() methods
	 */
	public int run(String[] args) throws Exception {
		int kmeans = 0, iterations = 0;
		Path inputPath = null, outputPath = null;
		HamaConfiguration conf = new HamaConfiguration(getConf());
		
		// Set arguments
		if (args.length < 2) {
			System.err.println("Error: too few parameters given");
			return printUsage();
		}
		inputPath = new Path(args[0]);
		outputPath = new Path(args[1]);
		try {
			kmeans = Integer.parseInt(args[2]);
			conf.setInt("kmeans", kmeans);
			iterations = Integer.parseInt(args[3]);
			conf.setInt("iterations", iterations);
		} catch (NumberFormatException e) {
			System.err.println("Error: expected Integers instead of " + args[2] + " (arg 2) and " + args[3] + " (arg 3)");
			return printUsage();
		}
		if (args.length > 4 && args[4].equals("combine")) {
			conf.setBoolean("combine", true);
		}
		else {
			conf.setBoolean("combine", false);
		}
		
		// Create and start a job
		BSPJob job = createJob(conf, inputPath, outputPath, kmeans);
		long startTime = System.currentTimeMillis();
		if (job.waitForCompletion(true)) {
			System.out.println("Job Finished in " + (System.currentTimeMillis() - startTime) / 1000.0 + " seconds");
		}
		return 0;
	}
	
	public static void main(String[] args) throws Exception {
		int result = ToolRunner.run(new Configuration(), new KMeans(), args);
		System.exit(result);
	}
}
