import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Map.Entry;
import java.util.Random;

import org.apache.hadoop.conf.Configuration;
import org.apache.hadoop.conf.Configured;
import org.apache.hadoop.fs.Path;
import org.apache.hadoop.io.IntWritable;
import org.apache.hadoop.io.LongWritable;
import org.apache.hadoop.io.Text;
import org.apache.hadoop.util.Tool;
import org.apache.hadoop.util.ToolRunner;
import org.apache.hama.HamaConfiguration;
import org.apache.hama.bsp.BSP;
import org.apache.hama.bsp.BSPJob;
import org.apache.hama.bsp.BSPPeer;
import org.apache.hama.bsp.TextInputFormat;
import org.apache.hama.bsp.TextOutputFormat;
import org.apache.hama.bsp.sync.SyncException;

import types.Cluster;
import types.Point;
import types.ClusterMessage;

/**
 * Hama program to run the k-means algorithm
 * @author stevenb
 * @date 14-08-2013
 */
public class KMeans extends Configured implements Tool {
	
	public static final float CONVERGENCE_POINT = 0.01f;
	public static final String POINT = "POINT";//, OUTLIER = "OUTLIER"; // TODO REMOVE
	
	public static class KMeansBSP extends BSP<LongWritable, Text, IntWritable, Text, ClusterMessage> {
		
		private int kmeans, round, iterations;
		private Cluster me;
//		private Point mean; // TODO REMOVE
//		private Point[] outliers; // TODO REMOVE
		private ArrayList<Point> points;
		private HashMap<String, Cluster> clusters;
		
		private String peerName; // TODO REMOVE
		
		@Override
		public void setup(BSPPeer<LongWritable, Text, IntWritable, Text, ClusterMessage> peer) throws IOException { //initialize
			kmeans = peer.getNumPeers();
			round = 0;
			iterations = peer.getConfiguration().getInt("iterations", 0);
			
			me = new Cluster(peer.getPeerIndex(), 0, 0, new Point(), new Point[kmeans - 1]);
			
//			mean = new Point(); // TODO REMOVE
//			outliers = new Point[kmeans - 1]; // The total number of outliers in the system is kmeans - 1 times the number of peers // TODO REMOVE
			
			points = new ArrayList<Point>();
			clusters = new HashMap<String, Cluster>(kmeans);
			
			peerName = peer.getPeerName(); // TODO REMOVE
		}
		
		@Override
		/**
		 * The KMeans Clustering algorithm
		 * Starts of with an initialization of all the input data.
		 *  Then starts the iterative loop,
		 *  where it'll first synchronize, then check for new points
		 *  added to that cluster or new cluster means. After that
		 *  it checks whether some of its points have a shorter 
		 *  distance to another cluster. If so, it will reassign 
		 *  those points to that specific cluster. After reassigning,
		 *  it will recalculate it's mean and broadcasts this value
		 *  to the other clusters.
		 */
		public void bsp(BSPPeer<LongWritable, Text, IntWritable, Text, ClusterMessage> peer) throws IOException, InterruptedException, SyncException {
			boolean converged = false;
			initialize(peer);
			peer.sync();
			//receiveMessages(peer); // Receive the first, random appointed points
			while (!converged && round < iterations) {
//				System.out.printf("START:%d %s has cluster %s\n", round, peerName, me.toString());  // TODO REMOVE
				System.out.println("\n:start: " + peerName + "-" + round + " cluster: " + me.toString()); //TODO REMOVE
				
				if(round != 0){
					assignPoints(peer); // Map task | calculate distances and send to right cluster
					
					peer.sync(); // Synchronize after mapper task
				}
				
				receiveMessages(peer); // Receive the newly given points
				
				updateCluster(peer); // Update this cluster its info, since you now have new points | involves new mean, new outliers, and size setting
				
				peer.sync(); // Sync after second set-outlier phase
				
				converged = receiveMessages(peer); // Set the new clusters and check if converged...
				
				
//				System.out.println("Peer " + peer.getPeerIndex() + ", round " + round + ", Finished in " + (System.currentTimeMillis() - startTime) / 1000.0 + " seconds\n");
				System.out.println(":end: " + peerName + "-" + round + " cluster: " + me.toString() + "\n"); //TODO REMOVE
//				System.out.printf("END:%d %s has cluster %s\n", round, peerName, me.toString());
				
				round++;
			}
			
			
			//if(peer.getPeerIndex() == 0 && converged){ // TODO CHANGE
			if (converged) { // TODO CHANGE
				System.out.printf("PEERNAME:%S Clusters Converged in Iteration %d\n\n", peer.getPeerName(), round); // TODO CHANGE
				//} else if(peer.getPeerIndex() == 0) { // TODO CHANGE
			} else { // TODO CHANGE
				System.out.printf("PEERNAME:%S Clusters did not converge, but reached the maximum number of iterations\n\n", peer.getPeerName()); // TODO CHANGE
			} // TODO CHANGE
			for (Entry<String, Cluster> entry : clusters.entrySet()) { // TODO CHANGE
				System.out.printf("PEERNAME:%S Cluster %s:\t%s\n", peer.getPeerName(), entry.getKey(), entry.getValue().toString()); // TODO CHANGE
			} // TODO CHANGE
			System.out.printf("PEERNAME:%S Cluster size %d\n", peer.getPeerName(), points.size()); // TODO CHANGE
		}
		
		/**
		 * The first round of KMeans, hence first need to initialize
		 *  all the point to a cluster.
		 * Points are assigned randomly to a cluster (Random Partitioning)
		 *  within this program.
		 * @param peer: a BSPPeer object containing all the information about 
		 * 	this BSPPeer task.
		 * @throws IOException from the readNext() and send() methods.
		 */
		private void initialize(BSPPeer<LongWritable, Text, IntWritable, Text, ClusterMessage> peer) throws IOException {
//			System.out.println(":initialize: " + peerName + "-" + round); //TODO REMOVE
			LongWritable key = new LongWritable();
			Text value = new Text();
			String[] lines = null;
			
			while (peer.readNext(key, value)) {
				lines = value.toString().split("\n");
				for (int i = 0; i < lines.length; i++) {
					Random random = new Random();
					int clusterIndex = random.nextInt(kmeans);
					Cluster point = new Cluster(-1, -1, -1, new Point(lines[i]), new Point[0]);
					
					ClusterMessage m = new ClusterMessage(POINT, point);
					String name = peer.getPeerName(clusterIndex);
					peer.send(name, m);
				}
			}
		}
		
		/**
		 * Receive all the messages send by other peers at this peer.
		 * Depending on the tag contained in the ClusterMessage object,
		 *  one can see whether it is a new point or a cluster centroid
		 *  message.
		 * @param peer: a BSPPeer object containing all the information about 
		 * 	this BSPPeer task.
		 * @return true or false depending on whether the algorithm converged
		 * @throws IOException from the getCurrentMessage() method.
		 */
		private boolean receiveMessages(BSPPeer<LongWritable, Text, IntWritable, Text, ClusterMessage> peer) throws IOException {
//			System.out.println(":receivemessages: " + peerName + "-" + round); //TODO REMOVE
			boolean convergence = false;
			int totalPointsReceived = peer.getNumCurrentMessages(), 
					received = 0; // TODO REMOVE
			HashMap<String, Cluster> newClusters = new HashMap<String, Cluster>(kmeans);
			
//			System.out.printf("PEERNAME:%S %d | Have %d points\n", peerName, round, points.size()); // TODO REMOVE
//			System.out.println(":receivemessages: " + peerName + "-" + round + "| have " + points.size() + " points"); //TODO REMOVE
			
			for (int i = 0; i < totalPointsReceived; i++) {
				ClusterMessage message = peer.getCurrentMessage();
				String tag = message.getTag();
				if (tag.equals(POINT)) { // Received a Point message
					points.add(message.getCluster().getCentroid());
					received++; // TODO REMOVE
				}  else { // Probably a Cluster mean
//					System.out.printf("PEERNAME:%S %d | Cluster: %s\n", peerName, round, message.toString()); // TODO REMOVE
					System.out.println(":receivemessages: " + peerName + "-" + round + "| " + tag + " received cluster" + message.getCluster()); //TODO REMOVE
					newClusters.put(tag, message.getCluster());
					System.out.println(":receivemessages: " + peerName + "-" + round + "| " + tag + " held cluster" + clusters.get(tag)); //TODO REMOVE
				}
			}
			
//			System.out.printf("PEERNAME:%S %d | Have received %d\n", peerName, round, received); // TODO REMOVE		
//			if(received > 0){//TODO REMOVE
//				System.out.println(":receivemessages: " + peerName + "-" + round + "| received " + received + " points"); //TODO REMOVE
//			}//TODO REMOVE
			if(newClusters.size() > 0){ // Only if any clusters are received, can we check for convergence and set the new clusters
				convergence = checkConvergence(newClusters);
				setNewClusters(newClusters);
			}
			return convergence;
		}
		
		/**
		 * Check whether the algorithm has converged, 
		 *  compared to the previous cluster centroid and
		 *  the current cluster centroids.
		 * @param newClusters: A HashMap object containing
		 *  the new cluster_name/mean combinations.
		 * @return true in case the algorithm, false
		 *  in case it did not.
		 */
		private boolean checkConvergence(HashMap<String, Cluster> newClusters) {
			System.out.println(":checkconvergence: " + peerName + "-" + round); //TODO REMOVE
			//			System.out.printf("PEERNAME:%S %d | Going to check convergence...\n", peerName, round); //TODO REMOVE
			if (clusters.size() != newClusters.size()) { // if the sizes do not equal, 'clusters' was smaller than kmeans the previous round; hence no convergence
//				setNewClusters(newClusters);
				System.out.println(":checkconvergence: " + peerName + "-" + round + "| inequal sizes | " + clusters.size() + " != " + newClusters.size()); //TODO REMOVE
				return false;
			}
//			for (int k = 0; k < currentClusters.length; k++) {
			for (Entry<String, Cluster> entry : clusters.entrySet()) {
				Cluster currentCluster = entry.getValue();
				Cluster newCluster = newClusters.get(entry.getKey());
				if (currentCluster.getSize() == 0 || newCluster.getSize() == 0) { // Found a cluster with no points, hence no mean to compare\
					System.out.println(":checkconvergence: " + peerName + "-" + round + "| empty cluster | " + currentCluster.getSize() + " == 0 || " + newCluster.getSize() + " == 0"); //TODO REMOVE
//					System.out.printf("CONVERGENCE: empty cluster in previous set or current set, hence false\n"); // TODO REMOVE
					return false; // Thus cannot check for convergence
				}
			}
			
			double cmp = 0.0;
			for (Entry<String, Cluster> entry : clusters.entrySet()) {
				Cluster currentCluster = entry.getValue();
				Cluster newCluster = newClusters.get(entry.getKey());
//				System.out.printf("CONVERGENCE:\n\tPre: %s\n\tCur: %s\n", previousClusters[k].toString(), currentClusters[k].toString()); // TODO REMOVE
				System.out.println(":checkconvergence: " + peerName + "-" + round + "| compare | \n" + currentCluster.getCentroid().toString() + "\n == \n" + newCluster.getCentroid().toString()); //TODO REMOVE
				cmp += currentCluster.getCentroid().compareTo(newCluster.getCentroid(), CONVERGENCE_POINT);
				if (cmp != 0) {
					return false;
				}
			}
			
//			for (Entry<String, Cluster> entry : clusters.entrySet()) {
//				Point oldCentroid = entry.getValue().getCentroid();
//				Point newCentroid = newClusters.get(entry.getKey()).getCentroid();
//				//				System.out.printf("PEERNAME:%S %d | Compare \t%s\t&\t%s\n", peerName, round, oldCentroid.toString(), newCentroid.toString()); //TODO REMOVE
//				if (oldCentroid.compareTo(newCentroid, CONVERGENCE_POINT) != 0) {
//					setNewClusters(newClusters);
//					return false;
//				}
//			}
//			setNewClusters(newClusters);
			return true;
		}
		
		/**
		 * Set the newly found clusters as
		 *  the current clusters
		 * @param newClusters: A HashMap containing the new clusters
		 */
		private void setNewClusters(HashMap<String, Cluster> newClusters) {
//			System.out.println(":setnewclusters: " + peerName + "-" + round); //TODO REMOVE
			int emptyClusters = 0;
			for (Entry<String, Cluster> entry : newClusters.entrySet()) {
				String name = entry.getKey(); // Retrieving/removing the key-value pair
				//Point mean = new Point(entry.getValue().getCoordinates(), new String[0]); // TODO CHANGE?
				Cluster cluster = entry.getValue(); // TODO CHANGE?
				if(cluster.getSize() <= 0){
					emptyClusters++;
				}
//				System.out.println(":setnewclusters: " + peerName + "-" + round + " found cluster: " + cluster.toString()); //TODO REMOVE
				
				clusters.remove(name); // Setting the new key-value pair
				clusters.put(name, cluster);
			}
			
			if(emptyClusters > 0){
				selectNewClusters(emptyClusters);
			}
		}
		
		private void selectNewClusters(int numEmptyClusters) {
			System.out.println(":selectnewclusters: " + peerName + "-" + round + "| found " + numEmptyClusters); //TODO REMOVE
//			System.out.printf("SELECT_NEW_CLUSTERS: Found %d empty cluster spots, will fill these!\n", numEmptyClusters); // TODO REMOVE
			int i = 0;
			String[] emptyClusterNames = new String[numEmptyClusters];
			Cluster largestCluster = new Cluster();
			for (Entry<String, Cluster> entry : clusters.entrySet()) {
//			for (int k = 0; k < clusters.length; k++) {
				// Find the indexes of the empty clusters
				if (entry.getValue().getSize() == 0) {
					emptyClusterNames[i] = entry.getKey();
					i++;
				} // Select the largest cluster to retrieve the outliers from to become new clusters 
				else if (entry.getValue().getSize() > largestCluster.getSize()) {
					largestCluster = entry.getValue();
				}
			}
			
			// Select the new cluster centroids
			Point[] outliers = largestCluster.getOutliers();
			for (int j = 0; j < numEmptyClusters; j++) {
				Cluster newCluster = clusters.get(emptyClusterNames[j]);
				newCluster.setCluster(newCluster.getIndex(), 1, largestCluster.getDimensions(), outliers[j], new Point[0]);
				
				
				clusters.remove(emptyClusterNames[j]); // Setting the new key-value pair
				clusters.put(emptyClusterNames[j], newCluster);
				
//				clusters[newCluster.getIndex()] = newCluster;
//				System.out.printf("SELECT_NEW_CLUSTERS: Filled %d with cluster %s\n", newCluster.getIndex(), newCluster.toString()); // TODO REMOVE
			}
			
//			return clusters;
		}
		
		/**
		 * Check whether a point contained in this cluster is 
		 *  closer to another clusters its mean. If so, assign 
		 *  that point to that clusters and remove it from your own.
		 * @param peer: a BSPPeer object containing all the information about 
		 * 	this BSPPeer task.
		 * @throws IOException from the send() method
		 */
		private void assignPoints(BSPPeer<LongWritable, Text, IntWritable, Text, ClusterMessage> peer) throws IOException {
//			System.out.println(":assignpoints: " + peerName + "-" + round); //TODO REMOVE
			int send = 0; // TODO REMOVE
			double dist = 0.0, minDist = Double.MAX_VALUE;
			String name = "";
			String[] clusterNames = peer.getAllPeerNames();
			Iterator<Point> pointsIterator = points.iterator();
			while (pointsIterator.hasNext()) {
				Point currentPoint = pointsIterator.next();
				
				for (String clusterName : clusterNames) {
					dist = currentPoint.calculateDistance(clusters.get(clusterName).getCentroid());
					if (dist < minDist) {
						minDist = dist;
						name = clusterName;
					}
				}
				// TODO round != 0 ????
				if (!name.equals(peer.getPeerName()) && round != 0) { // If the point did not stay in my cluster, send a message to the correct peer
					pointsIterator.remove();
					ClusterMessage m = new ClusterMessage(POINT, new Cluster(-1, -1, -1, currentPoint, new Point[0]));
//					System.out.printf("name: %s\n", name); // TODO REMOVE
					peer.send(name, m);
					send++; // TODO REMOVE
				}
			}
			
//			System.out.println(":assignpoints: " + peerName + "-" + round + "| assigned " + send + " points"); //TODO REMOVE
//			System.out.printf("PEERNAME:%S %d | Have send %d points // still have %d points\n", peerName, round, send, points.size()); // TODO REMOVE
		}
		
		/**
		 * 
		 * @param peer
		 * @throws IOException
		 */
		private void updateCluster(BSPPeer<LongWritable, Text, IntWritable, Text, ClusterMessage> peer) throws IOException {
//			System.out.println(":updatecluster: " + peerName + "-" + round); //TODO REMOVE
			me.setSize(points.size()); // Size setting
			recalculateMean(peer); // Centroid setting
			setOutliers(peer); // Outlier setting
			broadcastClusterInfo(peer); // Send your cluster info around
		}
		
		/**
		 * Recalculate the centroid of this cluster.
		 * @param peer: a BSPPeer object containing all the information about 
		 * 	this BSPPeer task.
		 * @throws IOException from the broadcastClusterInfo() method
		 */
		private void recalculateMean(BSPPeer<LongWritable, Text, IntWritable, Text, ClusterMessage> peer) throws IOException {
//			System.out.println(":recalculatemean: " + peerName + "-" + round); //TODO REMOVE
			int size = 0;
			Point newCentroid = new Point();
			for (Point point : points) {
				if (size == 0) {
					newCentroid.setCoordinates(point.getCoordinates());
				} else {
					newCentroid.add(point);
				}
				size++;
			}
			newCentroid.divide(size);
			//mean = new Point(newCentroid.getCoordinates(), new String[0]); // TODO CHANGE?
			me.setCentroid(newCentroid);
//			mean = newCentroid; // TODO CHANGE?
//			broadcastClusterInfo(peer);
		}
		
		/**
		 * Set the k - 1 outliers of this cluster, by 
		 *  calculating which points have the largest
		 *  distance to the center 
		 * @param peer: a BSPPeer object containing all the information about 
		 * 	this BSPPeer task.
		 * @throws IOException from the broadcastOutliers() method.
		 */
		private void setOutliers(BSPPeer<LongWritable, Text, IntWritable, Text, ClusterMessage> peer) throws IOException {
//			System.out.println(":setouliers: " + peerName + "-" + round); //TODO REMOVE
//			System.out.printf("SET_OUTLIERS Round:%d-Peer:%s | number of points in cluster: %d and going to calculate with %s\n", round, peerName, points.size(), mean.toString()); // TODO REMOVE
//			for(Point outlier : newOutliers){ // TODO REMOVE
//				if(outlier != null){
//					System.out.printf("PEERNAME:%S %d | BEFORE newOutlier: %s\n", peerName, round, outlier.toString()); // TODO REMOVE
//				} else {
//					System.out.printf("PEERNAME:%S %d | BEFORE newOutlier: null\n", peerName, round); // TODO REMOVE
//				}
//			} // TODO REMOVE
//			for(Point outlier : outliers){ // TODO REMOVE
//				if(outlier != null){
//					System.out.printf("PEERNAME:%S %d | BEFORE outlier: %s\n", peerName, round, outlier.toString()); // TODO REMOVE
//				} else {
//					System.out.printf("PEERNAME:%S %d | BEFORE outlier: null\n", peerName, round); // TODO REMOVE
//				}
//			} // TODO REMOVE
			
			int i = 0; // TODO REMOVE
			Point centroid = me.getCentroid();
			Point[] outliers = me.getOutliers();
			Point[] newOutliers = new Point[outliers.length];
			for (Point point : points) {
				boolean gotPosition = false;
				double dist = point.calculateDistance(centroid);
				for (int k = 0; k < outliers.length; k++) {
					//					System.out.printf("PEERNAME:%S %d | k = %d\n", peerName, round, k); // TODO REMOVE
					if (!gotPosition) {
						//						System.out.printf("PEERNAME:%S %d | newOutliers[%d](%s) = outliers[%d](%s)\n", peerName, round, k, newOutliers[k], k, outliers[k].toString()); // TODO REMOVE
						newOutliers[k] = outliers[k];
						if (newOutliers[k] == null || outliers[k].calculateDistance(centroid) < dist) {
							newOutliers[k] = new Point(point.getCoordinates(), new String[0]);
							//							System.out.printf("PEERNAME:%S %d | newOutliers[%d](%s) = new Point(%s)\n", peerName, round, k, newOutliers[k], point.toString()); // TODO REMOVE
							gotPosition = true;
						}
					} else {
						//						System.out.printf("PEERNAME:%S %d | newOutliers[%d](%s) = outliers[%d](%s)\n", peerName, round, k, newOutliers[k], (k - 1), outliers[k].toString()); // TODO REMOVE
						newOutliers[k] = outliers[k - 1];
					}
				}
				i++; // TODO REMOVE
				outliers = Arrays.copyOf(newOutliers, newOutliers.length);
			}
			me.setOutliers(newOutliers);
//			System.out.printf("PEERNAME:%S %d | done %d points\n", peerName, round, i); // TODO REMOVE

//			outliers = newOutliers;
//			for(Point outlier : newOutliers){ // TODO REMOVE
//				if(outlier != null){
//					System.out.printf("PEERNAME:%S %d | AFTER newOutlier: %s\n", peerName, round, outlier.toString()); // TODO REMOVE
//				} else {
//					System.out.printf("PEERNAME:%S %d | AFTER newOutlier: null\n", peerName, round); // TODO REMOVE
//				}
//			} // TODO REMOVE
//			for(Point outlier : outliers){ // TODO REMOVE
//				if(outlier != null){
//					System.out.printf("PEERNAME:%S %d | AFTER outlier: %s\n", peerName, round, outlier.toString()); // TODO REMOVE
//				} else {
//					System.out.printf("PEERNAME:%S %d | AFTER outlier: null\n", peerName, round); // TODO REMOVE
//				}
//			} // TODO REMOVE
//			broadcastOutliers(peer);
		}
		
		/**
		 * Broadcast the newly calculated centroid of this cluster
		 *  to the other clusters.
		 * @param peer: a BSPPeer object containing all the information about 
		 * 	this BSPPeer task.
		 * @throws IOException from the send() method
		 */
		private void broadcastClusterInfo(BSPPeer<LongWritable, Text, IntWritable, Text, ClusterMessage> peer) throws IOException {
//			System.out.println(":broadcast: " + peerName + "-" + round); //TODO REMOVE
			String[] clusterNames = peer.getAllPeerNames();
			Cluster copy = new Cluster(me.getIndex(), me.getSize(), me.getDimensions(), me.getCentroid(), me.getOutliers());
			for (String clusterName : clusterNames) {
				//				ClusterMessage m = new ClusterMessage(peer.getPeerName(), new Point(newCentroid.getCoordinates(), new String[0])); // TODO CHANGE?
				ClusterMessage m = new ClusterMessage(peer.getPeerName(), copy); // TODO CHANGE?
				peer.send(clusterName, m);
			}
		}
		
//		/**
//		 * Send one of your outliers to each respective cluster
//		 * @param peer: a BSPPeer object containing all the information about 
//		 * 	this BSPPeer task.
//		 * @throws IOException from the send() method.
//		 */
//		private void broadcastOutliers(BSPPeer<LongWritable, Text, IntWritable, Text, ClusterMessage> peer) throws IOException {
//			String[] clusterNames = peer.getAllPeerNames();
//			for(String clusterName : clusterNames){
//				ClusterMessage m = new ClusterMessage(peer.getPeerName(), me);
//				peer.send(clusterName, m);
//			}
//		}
		
		@Override
		public void cleanup(BSPPeer<LongWritable, Text, IntWritable, Text, ClusterMessage> peer) throws IOException { // Close
			for (Point point : points) { // Write the mean - Point pairs out to a file
				peer.write(new IntWritable(me.getIndex()), new Text(point.toString()));
			}
			points.clear(); // Empty memory
		}
	}
	
	/**
	 * Create the job.
	 * @param args: String array of arguments
	 * @param conf: a HamaConfiguration Object for the BSP job
	 * @return a finalized BSPJob Object for this BSP job
	 * @throws IOException for creating the BSP job Object
	 */
	public static BSPJob createJob(HamaConfiguration conf, Path inputPath, Path outputPath, int kmeans) throws IOException {
		BSPJob job = new BSPJob(conf, KMeans.class); // Main settings
		job.setJobName("KMeans Clustering");
		job.setBspClass(KMeansBSP.class);
		job.setNumBspTask(kmeans);
		job.setInputPath(inputPath); // Input settings
		job.setInputFormat(TextInputFormat.class);
		job.setInputKeyClass(LongWritable.class);
		job.setInputValueClass(Text.class);
		job.setOutputPath(outputPath); // Output settings
		job.setOutputFormat(TextOutputFormat.class);
		job.setOutputKeyClass(Point.class);
		job.setOutputValueClass(Text.class);
		
		return job;
	}
	
	/**
	 * Prints out the usages of this program in case the user
	 *  gave incorrect input
	 * @param numArgs: number of arguments in the String array object
	 */
	private int printUsage() {
		System.out.println("usage:\t <input path> <output path> <k mean points> <number of iterations> <[OPTIONAL] add 'combine' to use inmapper combiner>");
		ToolRunner.printGenericCommandUsage(System.out);
		return -1;
	}
	
	@Override
	/**
	 * Runs the main program
	 * 
	 * @param args: String array of arguments given at start 
	 * @return -1 in case of error | 0 in case of success
	 * @throws Exception from the createJob() and the waitForCompletion() methods
	 */
	public int run(String[] args) throws Exception {
		int kmeans = 0, iterations = 0;
		Path inputPath = null, outputPath = null;
		HamaConfiguration conf = new HamaConfiguration(getConf());
		
		// Set arguments
		if (args.length < 2) {
			System.err.println("Error: too few parameters given");
			return printUsage();
		}
		inputPath = new Path(args[0]);
		outputPath = new Path(args[1]);
		try {
			kmeans = Integer.parseInt(args[2]);
			conf.setInt("kmeans", kmeans);
			iterations = Integer.parseInt(args[3]);
			conf.setInt("iterations", iterations);
		} catch (NumberFormatException e) {
			System.err.println("Error: expected Integers instead of " + args[2] + " (arg 2) and " + args[3] + " (arg 3)");
			return printUsage();
		}
		if (args.length > 4 && args[4].equals("combine")) {
			conf.setBoolean("combine", true);
		}
		else {
			conf.setBoolean("combine", false);
		}
		
		// Create and start a job
		BSPJob job = createJob(conf, inputPath, outputPath, kmeans);
		long startTime = System.currentTimeMillis();
		if (job.waitForCompletion(true)) {
			System.out.println("Job Finished in " + (System.currentTimeMillis() - startTime) / 1000.0 + " seconds");
		}
		return 0;
	}
	
	public static void main(String[] args) throws Exception {
		int result = ToolRunner.run(new Configuration(), new KMeans(), args);
		System.exit(result);
	}
}
