package nl.vu.cs.cn;

import java.io.IOException;
import java.nio.ByteBuffer;

/** 
 * @author Steven van Beelen, 1821806 
 * @coauthor Gerben Rozie 
 *  
 * This class serves as the representation of a 
 *  TCP segment, the packets which are send and received. 
 * The segment contains the TCP Header and the actual  
 *  data which is send and received. 
 */
public class TcpSegment {
	
	public TcpHeader tcpHeader;
	public byte[] data;
	
	/** 
	 * Construct a TCP Segment 
	 *  
	 * @param tcpHeader: The header of a TCP segment, containing all relevant connection information 
	 * @param data: The actual data send with the TCP segment 
	 */
	public TcpSegment(TcpHeader tcpHeader, byte[] data) {
		this.tcpHeader = tcpHeader;
		this.data = data;
	}
	
	/** 
	 * Default TCP Segment constructor 
	 */
	public TcpSegment() {
		this(new TcpHeader(), null);
	}
	
	/**  
	 * The length of a TCP Segment consists of
	 *  the length of the TCP Header and the length
	 *  of the data segment.
	 * 
	 * @return a short variable containing the number of bytes
	 *  of a TCP segment 
	 */
	public short length() {
		return (short) (tcpHeader.length() + data.length);
	}
	
	/** 
	 * Sets the checksum for this tcp segment to  
	 *  the given checksum parameter
	 *  
	 * @param checksum: the checksum calculated for  
	 *  the complete packet (pseudoheader + tcpheader + data) 
	 */
	public void setChecksum(int checksum) {
		tcpHeader.checksum = (short) checksum;
	}
	
	/** 
	 * Computes the checksum for this tcp segment and returns it as a short
	 * 
	 * First adds the ones complement of the pseudoheader to
	 *  a sum integer. After that, it will add the ones complement
	 *  of the TCP segment to the sum integer.
	 * The sum is stored as an integer, since the carries should be
	 *  wrapped in to it afterwards.
	 *  
	 * @param ps: PseudoHeader used to compute the checksum 
	 * @return returns the computed checksum as a short
	 */
	public short computeChecksum(PseudoHeader ph) {
		int sum = 0;
		ByteBuffer bb = ByteBuffer.allocate(4);
		bb.put(0, (byte) 0);
		bb.put(1, (byte) 0);
		byte[] ph_byte_array = null, tcp_byte_array = null;
		try {
			ph_byte_array = ph.getByteArray();
			tcp_byte_array = getByteArray();
		} catch (IOException e1) {
			System.err.println("Error: retrieving ByteArray from PseudoHeader or TCPSegment failed");
			e1.printStackTrace();
			return -1;
		}
		
		// Loop to add all 16bit words (shorts) together from the pseudoheader
		for (int i = 0; i < ph_byte_array.length; i += 2) {
			bb.put(2, ph_byte_array[i]);
			bb.put(3, ph_byte_array[i + 1]);
			sum += bb.getInt();
			bb.rewind();
		}
		
		// Loop to add all 16bit words (shorts) together from the tcp segment
		for (int i = 0; i < tcp_byte_array.length; i += 2) {
			bb.put(2, tcp_byte_array[i]);
			if (i + 1 == tcp_byte_array.length) {
				bb.put(3, (byte) 0); //The zero padding if the TCP byte array has an odd number of bytes
			}
			else {
				bb.put(3, tcp_byte_array[i + 1]);
			}
			sum += bb.getInt();
			bb.rewind();
		}
		
		// Wrap the carries over to 16 bit/fold 32bit to 16bit
		while (sum >> 16 >= 1) {
			sum = (sum & 0xFFFF) + (sum >> 16);
		}
		
		return (short) ~((short) sum); // '~' used to retrieve the complement of checksum
	}
	
	/** 
	 * validates the checksum of an incoming packet 
	 *  
	 * @return  True: Checksum is correct 
	 *          False: Checksum is incorrect 
	 */
	public boolean validateChecksum(PseudoHeader ph) {
		//		System.out.printf("VALIDATE_CHECKSUM: Will now compute the checksum of the received packet...\n");
		int checksum = computeChecksum(ph);
		//		System.out.printf("VALIDATE_CHECKSUM: Computed Checksum: %d | Complement of Computed Checksum: %d\n" +
		//				"\tWill now compute with checksum of the received packet set to 0...\n", checksum, (short) ~checksum);
		//return ((short) checksum + tcpHeader.checksum) == 0;
		return checksum == 0;
	}
	
	/** 
	 * @return returns a byte array of this tcp segment 
	 */
	public byte[] getByteArray() throws java.io.IOException {
		byte[] header, segment;
		
		header = tcpHeader.getByteArray();
		segment = new byte[header.length + data.length];
		System.arraycopy(header, 0, segment, 0, header.length);
		System.arraycopy(data, 0, segment, header.length, data.length);
		
		return segment;
	}
}
