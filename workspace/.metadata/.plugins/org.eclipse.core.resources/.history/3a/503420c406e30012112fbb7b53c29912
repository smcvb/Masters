package nl.vu.cs.cn;

import java.io.IOException;
import java.nio.ByteBuffer;

/** 
 * @author Steven van Beelen, 1821806 
 * @coauthor Gerben Rozie 
 *  
 * This class serves as the representation of a 
 *  TCP segment, the packets which are send and received. 
 * The segment contains the TCP Header and the actual  
 *  data which is send and received. 
 */
public class TcpSegment {
	
	public TcpHeader tcpHeader;
	public byte[] data;
	
	/** 
	 * Construct a TCP Segment 
	 *  
	 * @param tcpHeader: The header of a TCP segment, containing all relevant connection information 
	 * @param data: The actual data send with the TCP segment 
	 */
	public TcpSegment(TcpHeader tcpHeader, byte[] data) {
		this.tcpHeader = tcpHeader;
		this.data = data;
	}
	
	/** 
	 * Default TCP Segment constructor 
	 */
	public TcpSegment() {
		this(new TcpHeader(), null);
	}
	
	/**  
	 * The length of a TCP Segment consists of
	 *  the length of the TCP Header and the length
	 *  of the data segment.
	 * 
	 * @return a short variable containing the number of bytes
	 *  of a TCP segment 
	 */
	public short length() {
		return (short) (tcpHeader.length() + data.length);
	}
	
	/** 
	 * Sets the checksum for this tcp segment to  
	 *  the given checksum parameter
	 *  
	 * @param checksum: the checksum calculated for  
	 *  the complete packet (pseudoheader + tcpheader + data) 
	 */
	public void setChecksum(int checksum) {
		tcpHeader.checksum = (short) checksum;
	}
	
	/** 
	 * Computes the checksum for this tcp segment and returns it as a short  
	 *  
	 * @param ps: PseudoHeader used to compute the checksum 
	 * @return returns the computed checksum as a short 
	 */
	public short computeChecksum(PseudoHeader ph) {
		int sum = 0;
		ByteBuffer bb = ByteBuffer.allocate(4);
		byte[] ph_byte_array = null, tcp_byte_array = null;
		try {
			ph_byte_array = ph.getByteArray();
			tcp_byte_array = getByteArray();
		} catch (IOException e1) {
			e1.printStackTrace();
			System.err.println("Error: retrieving ByteArray from PseudoHeader or TCPSegment failed");
			return -1;
		}
//		System.out.printf("COMPUTE_CHECKSUM: sum pseudoheader\n");
		bb.put(0, (byte) 0);
		bb.put(1, (byte) 0);
		/** Loop to add all 16bit words (shorts) together from the pseudoheader */
		for (int i = 0; i < ph_byte_array.length; i += 2) {
			bb.put(2, ph_byte_array[i]);
			bb.put(3, ph_byte_array[i + 1]);
			//bb.rewind();
			int partial = bb.getInt();
//			System.out.printf(" %d ", partial);
//			System.out.printf("COMPUTE_CHECKSUM: %d\n", partial);
			sum += partial;
			bb.rewind();
		}
//		System.out.printf("COMPUTE_CHECKSUM: sum tcpsegment\n");
		/** Loop to add all 16bit words (shorts) together from the tcp segment */
		for (int i = 0; i < tcp_byte_array.length; i += 2) {
//			if (i == 16) {
//				continue; // don't take checksum in calculation
//			}
			bb.put(2, tcp_byte_array[i]);
			if (i + 1 == tcp_byte_array.length) {
				bb.put(3, (byte) 0); //The zero padding 
			}
			else {
				bb.put(3, tcp_byte_array[i + 1]);
			}
			int partial = bb.getInt();
//			System.out.printf("COMPUTE_CHECKSUM: %d\n", partial);
//			System.out.printf(" %d ", partial);
			sum += partial;
			bb.rewind();
		}
//		System.out.printf("COMPUTE_CHECKSUM: total sum of pseudoheader + tcpsegment = %d before folding\n" +
//				"\twill fold carries in 16bit/short\n", sum);
		/** Wrap the carries over to 16 bit/fold 32bit to 16bit */
		while (sum >> 16 >= 1) {
			sum = (sum & 0xFFFF) + (sum >> 16);
		}
//		System.out.printf("COMPUTE_CHECKSUM: total sum of pseudoheader + tcpsegment = %d after folding\n", sum);
//		System.out.printf("COMPUTE_CHECKSUM: Complement of computed sum %d\n", (short) ~((short) sum));
		/** '~' used to retrieve the complement of checksum */
		return (short) ~((short) sum);
	}
	
	/** 
	 * validates the checksum of an incoming packet 
	 *  
	 * @return  True: Checksum is correct 
	 *          False: Checksum is incorrect 
	 */
	public boolean validateChecksum(PseudoHeader ph) {
//		System.out.printf("VALIDATE_CHECKSUM: Will now compute the checksum of the received packet...\n");
		int checksum = computeChecksum(ph);
//		System.out.printf("VALIDATE_CHECKSUM: Computed Checksum: %d | Complement of Computed Checksum: %d\n" +
//				"\tWill now compute with checksum of the received packet set to 0...\n", checksum, (short) ~checksum);
		//return ((short) checksum + tcpHeader.checksum) == 0;
		return checksum == 0;
	}
	
	/** 
	 * @return returns a byte array of this tcp segment 
	 */
	public byte[] getByteArray() throws java.io.IOException {
		byte[] header, segment;
		
		header = tcpHeader.getByteArray();
		segment = new byte[header.length + data.length];
		System.arraycopy(header, 0, segment, 0, header.length);
		System.arraycopy(data, 0, segment, header.length, data.length);
		
		return segment;
	}
}
