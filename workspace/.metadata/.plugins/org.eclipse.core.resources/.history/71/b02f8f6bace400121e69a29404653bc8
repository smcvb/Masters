package nl.vu.cs.cn.test;

import java.io.IOException;
import java.util.Random;

import junit.framework.TestCase;
import nl.vu.cs.cn.IP;
import nl.vu.cs.cn.IP.IpAddress;
import nl.vu.cs.cn.IP.Packet;
import nl.vu.cs.cn.PseudoHeader;
import nl.vu.cs.cn.TCPImplementation;
import nl.vu.cs.cn.TCPImplementation.SocketImplementation;
import nl.vu.cs.cn.TcpHeader;
import nl.vu.cs.cn.TcpSegment;

/**
 * This test performs a check on the proper handling of corrupted data
 * - the server accepts a connection
 * - the client connects
 * - the client writes data
 * - the server reads data
 * - data is corrupt
 * - the client retransmits data
 * - the server reads data
 * - the read data is the same as what was written
 * - both close the connection
 */
public class TcpCorruptData extends TestCase {

	public static final int ADDR = 130;
	public static final int PORT = 1234;
	public static final int MSG_SIZE = 512;
	private TCPImplementation tcp1;
	private TcpClient tcp2;
	
	/**
	 * This class represents the accepter thread.
	 */
	private class Server implements Runnable {
		
		private SocketImplementation sock;
		private IpAddress ip_addr;
		
		public Server(TCPImplementation tcp) {
			sock = tcp.socket(PORT);
			assertNotNull(sock);
			assertEquals(sock.port, PORT);
			ip_addr = tcp.ip.getLocalAddress();
			assertNotNull(ip_addr);
		}
		
		@Override
		public void run() {
			sock.accept();
			byte[] buf = new byte[10];
			int bytesRead = sock.read(buf, 0, buf.length);
			assertEquals(bytesRead, buf.length);
			for (int i = 0; i < buf.length; i++) {
				assertEquals((byte) i, buf[i]);
			}
			boolean result = sock.close();
			assertTrue(result);
		}	
	}
	
	/**
	 * This class represents the modified TCP stack that the client will use
	 */
	private class TcpClient extends TCPImplementation {
		
		private boolean corrupt;
		
		public TcpClient(int address) throws IOException {
			super(address);
			corrupt = true;
		}
		
		/**
		 * Using the override on the send_tcp_packet function we can modify a random byte of data if the packet has any
		 */
		@Override
		public int send_tcp_packet(IpAddress dest_ipaddr, short dest_port, short src_port, int seqnum, int acknum, byte flags, short window_size, byte[] data, int data_size) {
			int bytesSent;
			short checksum = 0, urg_pointer = 0;
			byte data_offset = 0x05;
			
			TcpHeader tcpHead = new TcpHeader(src_port, dest_port, seqnum, acknum, data_offset, flags, window_size, checksum, urg_pointer);
			TcpSegment tcpSeg = new TcpSegment(tcpHead, data);
			PseudoHeader ph = new PseudoHeader(ip.getLocalAddress(), dest_ipaddr, (byte) 0, (byte) IP.TCP_PROTOCOL, tcpSeg.length());
			checksum = tcpSeg.computeChecksum(ph);
			tcpSeg.setChecksum(checksum);
			
			byte[] tcpSegBytes = null;
			try {
				tcpSegBytes = tcpSeg.getByteArray();
			} catch (IOException e1) {
				fail();
			}
			if (corrupt && tcpSeg.data.length > 0) {
				int index = new Random().nextInt(tcpSegBytes.length - 20);
				tcpSegBytes[index + 20] = (byte) ~tcpSegBytes[index + 20];
				corrupt = false;
			}
			
			debugPrint("SND_TCP_PAC:%d Computed Checksum: %d\n", tcb.src_port, checksum);
			
			Packet p = null;
			try {
				p = new Packet(dest_ipaddr.getAddress(), IP.TCP_PROTOCOL, 2, tcpSeg.getByteArray(), tcpSeg.length());
			} catch (IOException e) {
				System.err.println("Error: failed creating a packet");
				return -1;
			}
			
			try {
				debugPrint("SND_TCP_PAC:%d Trying to send a packet... | State: %s\n", tcb.src_port, tcb.state);
				bytesSent = ip.ip_send(p);
				debugPrint("SND_TCP_PAC:%d Sending the packet was successful | BytesSent: %d (datalength + tcpheader)\tState: %s\n", tcb.src_port, bytesSent, tcb.state);
			} catch (IOException e) {
				System.err.println("Error: failed sending a packet");
				return -1;
			}
			return bytesSent;
		}
	}
	
	/**
	 * This class represents the connecter thread.
	 */
	private class Client implements Runnable {
		
		private SocketImplementation sock;
		private IpAddress ip_addr;
		private IpAddress dst_addr;
		
		public Client(TcpClient tcp, IpAddress dst_addr) {
			sock = tcp.socket(PORT - 1);
			assertNotNull(sock);
			assertEquals(sock.port, PORT - 1);
			ip_addr = tcp.ip.getLocalAddress();
			assertNotNull(ip_addr);
			this.dst_addr = dst_addr;
		}
		
		@Override
		public void run() {
			boolean result;
			do {
				result = sock.connect(dst_addr, PORT);
			} while (!result);
			byte[] buf = new byte[10];
			for (int i = 0; i < buf.length; i++) {
				buf[i] = (byte) i;
			}
			int bytesWritten = sock.write(buf, 0, buf.length);
			assertEquals(bytesWritten, buf.length);
			result = sock.close();
			assertTrue(result);
		}
	}
	
	public TcpCorruptData(String method) {
		super(method);
	}
	
	/**
	 * This method will be called by the testSuite to start the test
	 */
	public void testCorruptData() {
		System.setProperty("PACKET_LOSS", "0");
		System.setProperty("PACKET_CORRUPTION", "0");
		try {
			tcp1 = new TCPImplementation(ADDR);
			tcp2 = new TcpClient(ADDR + 1);
		} catch (IOException e) {
			fail();
		}
		Server s = new Server(tcp1);
		Client c = new Client(tcp2, tcp1.ip.getLocalAddress());
		assertNotNull(s);
		assertNotNull(c);
		Thread server = new Thread(s);
		Thread client = new Thread(c);
		server.start();
		client.start();
		// use a timeout to avoid infinite loops of code and fail the test if such timeout is reached
		try {
			client.join(15000);
			server.join(1);
			System.out.flush();
		} catch (InterruptedException e) {
			fail();
		}
	}
}
