package nl.vu.cs.cn.test;

import java.io.IOException;
import java.nio.ByteBuffer;
import java.nio.ByteOrder;

import junit.framework.TestCase;
import nl.vu.cs.cn.DebugPacket;
import nl.vu.cs.cn.IP.IpAddress;
import nl.vu.cs.cn.IP.Packet;
import nl.vu.cs.cn.TCB;
import nl.vu.cs.cn.TCPImplementation;
import nl.vu.cs.cn.TCPImplementation.SocketImplementation;
import nl.vu.cs.cn.TcpHeader;
import nl.vu.cs.cn.TcpSegment;

/**
 * This test performs a check on the proper handling of a packet with a length shorter
 *  than its buffer size
 * - the server accepts a connection
 * - the client connects
 * - the client writes data
 * - the server reads data
 * - the server notices an invalid packet (and simply waits for another packet)
 * - the client retransmits data
 * - the server reads data
 * - the read data is the same as what was written
 * - both close the connection
 */
public class TcpCorruptIPLengthShorter extends TestCase {
	public static final int ADDR = 130;
	public static final int PORT = 1234;
	public static final int MSG_SIZE = 512;
	private TCPImplementation tcp1;
	private TcpClient tcp2;
	
	/**
	 * This class represents the accepter thread.
	 */
	private class Server implements Runnable {
		
		private SocketImplementation sock;
		private IpAddress ip_addr;
		
		public Server(TCPImplementation tcp) {
			sock = tcp.socket(PORT);
			assertNotNull(sock);
			assertEquals(sock.port, PORT);
			ip_addr = tcp.ip.getLocalAddress();
			assertNotNull(ip_addr);
		}
		
		@Override
		public void run() {
			sock.accept();
			byte[] buf = new byte[10];
			int bytesRead = sock.read(buf, 0, buf.length);
			assertEquals(bytesRead, buf.length);
			for (int i = 0; i < buf.length; i++) {
				assertEquals((byte) i, buf[i]);
			}
			boolean result = sock.close();
			assertTrue(result);
		}
		
	}
	
	/**
	 * This class represents the modified TCP stack that the client will use
	 */
	private class TcpClient extends TCPImplementation {
		
		private boolean corrupt;
		
		public TcpClient(int address) throws IOException {
			super(address);
			corrupt = true;
		}
		
		/**
		 * Using the override on the decodePakcet function we can alter the packet data
		 */
		@Override
		public TcpSegment decodePacket(Packet p) throws Exception {
			short src_port = (short) 0;
			short dest_port = (short) 0;
			int seqnum = 0;
			int acknum = 0;
			byte data_offset = (byte) 0;
			byte flags = (byte) 0;
			short window_size = 0;
			short checksum = (short) 0;
			short urg_pointer = (short) 0;
			byte[] data = new byte[TCB.BUF_SIZE];
			
			ByteBuffer shortBuffer = ByteBuffer.allocate(2);
			ByteBuffer intBuffer = ByteBuffer.allocate(4);
			shortBuffer.order(ByteOrder.BIG_ENDIAN);
			intBuffer.order(ByteOrder.BIG_ENDIAN);
			
			// Because the packet is final and its data limited to package access
			//  we were resorted to making a copy of the packet in a new class
			// From this copy we can read (public access to the data) and modify
			//  the values
			DebugPacket dP = new DebugPacket(p);
			if (corrupt) {
				dP.length -= 2;
				corrupt = false;
			}
			
			shortBuffer.put(dP.data[0]);
			shortBuffer.put(dP.data[1]);
			shortBuffer.rewind();
			src_port = shortBuffer.getShort(); //SRC_PORT
			shortBuffer.rewind();
			shortBuffer.put(dP.data[2]);
			shortBuffer.put(dP.data[3]);
			shortBuffer.rewind();
			dest_port = shortBuffer.getShort(); //DEST_PORT
			shortBuffer.rewind();
			intBuffer.put(dP.data[4]);
			intBuffer.put(dP.data[5]);
			intBuffer.put(dP.data[6]);
			intBuffer.put(dP.data[7]);
			intBuffer.rewind();
			seqnum = intBuffer.getInt(); //SEQNUM
			intBuffer.rewind();
			intBuffer.put(dP.data[8]);
			intBuffer.put(dP.data[9]);
			intBuffer.put(dP.data[10]);
			intBuffer.put(dP.data[11]);
			intBuffer.rewind();
			acknum = intBuffer.getInt(); //ACKNUM
			intBuffer.rewind();
			data_offset = dP.data[12]; //DATA_OFFSET
			flags = dP.data[13]; //FLAGS
			shortBuffer.put(dP.data[14]);
			shortBuffer.put(dP.data[15]);
			shortBuffer.rewind();
			window_size = shortBuffer.getShort(); //WINDOW_SIZE
			shortBuffer.rewind();
			shortBuffer.put(dP.data[16]);
			shortBuffer.put(dP.data[17]);
			shortBuffer.rewind();
			checksum = shortBuffer.getShort(); //CHECKSUM
			shortBuffer.rewind();
			shortBuffer.put(dP.data[18]);
			shortBuffer.put(dP.data[19]);
			shortBuffer.rewind();
			urg_pointer = shortBuffer.getShort(); //URG_POINTER
			shortBuffer.rewind();
			data = new byte[dP.length - 20]; //DATA
			System.arraycopy(dP.data, 20, data, 0, dP.length - 20);
			
			return new TcpSegment(new TcpHeader(src_port, dest_port, seqnum, acknum, data_offset, flags, window_size, checksum, urg_pointer), data);
		}
	}
	
	/**
	 * This class represents the connecter thread.
	 */
	private class Client implements Runnable {
		
		private SocketImplementation sock;
		private IpAddress ip_addr;
		private IpAddress dst_addr;
		
		public Client(TcpClient tcp, IpAddress dst_addr) {
			sock = tcp.socket(PORT - 1);
			assertNotNull(sock);
			assertEquals(sock.port, PORT - 1);
			ip_addr = tcp.ip.getLocalAddress();
			assertNotNull(ip_addr);
			this.dst_addr = dst_addr;
		}
		
		@Override
		public void run() {
			boolean result;
			do {
				result = sock.connect(dst_addr, PORT);
			} while (!result);
			byte[] buf = new byte[10];
			for (int i = 0; i < buf.length; i++) {
				buf[i] = (byte) i;
			}
			int bytesWritten = sock.write(buf, 0, buf.length);
			assertEquals(bytesWritten, buf.length);
			result = sock.close();
			assertTrue(result);
		}
	}
	
	public TcpCorruptIPLengthShorter(String method) {
		super(method);
	}
	
	/**
	 * This method will be called by the testSuite to start the test
	 */
	public void testCorruptSeqNumber() {
		System.setProperty("PACKET_LOSS", "0");
		System.setProperty("PACKET_CORRUPTION", "0");
		try {
			tcp1 = new TCPImplementation(ADDR);
			tcp2 = new TcpClient(ADDR + 1);
		} catch (IOException e) {
			fail();
		}
		Server s = new Server(tcp1);
		Client c = new Client(tcp2, tcp1.ip.getLocalAddress());
		assertNotNull(s);
		assertNotNull(c);
		Thread server = new Thread(s);
		Thread client = new Thread(c);
		server.start();
		client.start();
		// use a timeout to avoid infinite loops of code and fail the test if such timeout is reached
		try {
			client.join(15000);
			server.join(1);
			System.out.flush();
		} catch (InterruptedException e) {
			fail();
		}
	}
}
