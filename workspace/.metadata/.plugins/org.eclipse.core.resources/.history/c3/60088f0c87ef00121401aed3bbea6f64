import java.io.EOFException;
import java.io.IOException;
import java.util.HashMap;
import java.util.Map.Entry;
import java.util.Random;

import org.apache.hadoop.conf.Configuration;
import org.apache.hadoop.conf.Configured;
import org.apache.hadoop.fs.FSDataOutputStream;
import org.apache.hadoop.fs.FileStatus;
import org.apache.hadoop.fs.FileSystem;
import org.apache.hadoop.fs.Path;
import org.apache.hadoop.io.IntWritable;
import org.apache.hadoop.io.LongWritable;
import org.apache.hadoop.io.Text;
import org.apache.hadoop.mapreduce.Job;
import org.apache.hadoop.mapreduce.Mapper;
import org.apache.hadoop.mapreduce.Reducer;
import org.apache.hadoop.mapreduce.lib.input.FileInputFormat;
import org.apache.hadoop.mapreduce.lib.input.TextInputFormat;
import org.apache.hadoop.mapreduce.lib.output.FileOutputFormat;
import org.apache.hadoop.mapreduce.lib.output.TextOutputFormat;
import org.apache.hadoop.util.LineReader;
import org.apache.hadoop.util.Tool;
import org.apache.hadoop.util.ToolRunner;

import types.Point;

/**
 * Hadoop program to run the k-means algorithm
 * @author stevenb
 * @date 17-07-2013
 */
public class KMeans extends Configured implements Tool {
	
	public static class Map extends Mapper<LongWritable, Text, IntWritable, Point> {
		
		private boolean firstIteration;
		private Point clusterMeans[], // the k clusters their mean point 
				points[]; // the number of points m to cluster over k
		private HashMap<Integer, Point> partialClusterMeanMap;
		
		@Override
		public void setup(Context context) throws IOException {
			Configuration conf = context.getConfiguration();
			int clusterIndex = -1;
			String meanPath = "", clusterMeanString = "";
			partialClusterMeanMap = new HashMap<Integer, Point>();
			
			// Not the first iteration | May use previously found cluster means
			if (!conf.getBoolean("FirstIteration", true)) {
				firstIteration = false;
				meanPath = conf.get("meansStringPath");
				clusterMeans = new Point[conf.getInt("NumKMeans", 0)];
				FileSystem fs = FileSystem.get(conf);
				for (FileStatus f : fs.listStatus(new Path(meanPath))) {
					// read a line from the path direction
					LineReader reader = new LineReader(fs.open(f.getPath()));
					Text clusterMeanText = new Text();
					reader.readLine(clusterMeanText);
					
					// parse the line into its index number and a coordinates string to store as a Point
					clusterMeanString = clusterMeanText.toString();
					String[] clusterMeanValues = clusterMeanString.split("+\\s");
					clusterIndex = Integer.parseInt(clusterMeanValues[0]);
					for (int i = 1; i < clusterMeanValues.length; i++) {
						clusterMeanString = clusterMeanString + " " + clusterMeanValues[i];
					}
					clusterMeans[clusterIndex] = new Point(clusterMeanString);
					
					// close this file
					reader.close();
				}
			} // First iteration | Use globally specified set of points from the overall set
			else {
				firstIteration = true;
			}
		}
		
		@Override
		public void map(LongWritable key, Text value, Context context) throws IOException, InterruptedException {
			String[] lines = value.toString().split("\n");
			points = new Point[lines.length]; // Initialize the number of Points this mapper will work through
			for (int i = 0; i < lines.length; i++) { // Start reading in a line and converting it to a Point object
				points[i] = new Point(lines[i]);
			}
			
			// Compute the Euclidean distances between all the point/mean combinations
			int clusterIndex = -1; // Integer representing the index number of the cluster mean the point belongs to
			double minDist = Double.MAX_VALUE, dist = 0.0;
			for (Point point : points) {
				if (!firstIteration) {
					for (int k = 0; k < clusterMeans.length; k++) {
						dist = point.calculateDistance(clusterMeans[k]);
						if (dist < minDist) {
							minDist = dist;
							clusterIndex = k;
						}
					}
				}
				else { // Appoint a random cluster index to a point if it is the first iteration
					Random random = new Random();
					clusterIndex = random.nextInt(context.getConfiguration().getInt("NumKMeans", 0));
				}
				
				// in mapper combine by calculating the partial mean of the cluster
				if (partialClusterMeanMap.containsKey(clusterIndex)) {
					Point partialClusterMean = partialClusterMeanMap.get(clusterIndex);
					partialClusterMean.add(point);
					partialClusterMean.divide(2);
					partialClusterMeanMap.put(clusterIndex, partialClusterMean);
				}
				else {
					partialClusterMeanMap.put(clusterIndex, point);
				}
			}
		}
		
		@Override
		public void cleanup(Context context) throws IOException, InterruptedException {
			for (Entry<Integer, Point> entry : partialClusterMeanMap.entrySet()) {
				IntWritable index = new IntWritable(entry.getKey());
				Point point = entry.getValue();
				context.write(index, point); // write all the partial cluster means to the reducers
			}
			partialClusterMeanMap.clear(); // Empty memory
		}
	}
	
	public static class Reduce extends Reducer<IntWritable, Point, Point, Point> {
		
		private Point recalculatedClusterMean;
		private Point[] clusterMeans;
		private int j; // TODO remove
		
		@Override
		public void setup(Context context) throws IOException {
			recalculatedClusterMean = new Point();
			clusterMeans = new Point[context.getConfiguration().getInt("NumKMeans", 0)];
			j = 0; // TODO remove
		}
		
		@Override
		public void reduce(IntWritable key, Iterable<Point> values, Context context) throws IOException, InterruptedException {
			System.out.printf("Round %d of reduce task %s\n", j, context.getConfiguration().get("mapred.task.id")); // TODO remove
			int i = 0;
			for (Point value : values) { // Repeat to find the new mean for
				if (i == 0) {
					recalculatedClusterMean = value; // The first value, hence only initialize the clusterMean object 
				}
				else {
					recalculatedClusterMean.add(value); // Add both points together
				}
				i++;
			}
			recalculatedClusterMean.divide(i); // Multiple by two to get there mean
			clusterMeans[key.get()] = recalculatedClusterMean; // Put the recalculated mean in the right position1
			for (Point value : values) { // Write every found point with its associated, recalculated mean
				context.write(value, recalculatedClusterMean);
			}
			j++; // TODO remove
		}
		
		@Override
		public void cleanup(Context context) throws IOException {
			Configuration conf = context.getConfiguration();
			String taskId = conf.get("mapred.task.id");
			Path meanPath = new Path(conf.get("meansStringPath") + "/" + taskId);
			FileSystem fs = FileSystem.get(conf);
			fs.delete(meanPath, true); // delete the previously found centers, since we have recalculated them
			FSDataOutputStream out = fs.create(meanPath, false);
			for (int i = 0; i < clusterMeans.length; i++) {
				if (clusterMeans[i] != null) {
					out.writeChars(i + "\t" + clusterMeans[i].toString() + "\n");
				}
			}
			out.close();
		}
	}
	
	/**
	 * Check whether the currents cluster means
	 *  equals the previous clusters means
	 * @param previousMeans: Point array containing the previous
	 * 	found cluster means
	 * @param currentMeans: Point array containing the current
	 * 	found cluster means
	 * @return True: in case all the means equal
	 * 	False: in case one or more of the cluster means
	 * 		do not equal
	 */
	private boolean checkConvergence(Point[] previousMeans, Point[] currentMeans) {
		if (previousMeans.length == 0) { // if this is the first iteration/checkConvergence()  method call, then its length will be zero
			return false;
		}
		
		int cmp = 0;
		for (int i = 0; i < previousMeans.length; i++) {
			cmp += Math.abs(previousMeans[i].compareTo(currentMeans[i]));
		}
		if (cmp > 0) { // if compareTo() returned something else than 0 thus not equal, 'cmp' should be bigger than 0
			return false;
		}
		return true;
	}
	
	/**
	 * Retrieve the recalculated cluster means from the reduce job
	 *  for sending them through convergence checking
	 * @param conf: A Configuration object containing the Map/Reduce 
	 * 	job configurations
	 * @param kmeans: Number of clusters means k as an integer
	 * @return: A Point array object containing the recalculated
	 * 	cluster means
	 * @throws IOException for errors in a FileSystem operation
	 */
	private Point[] getCalculatedMeans(Configuration conf, int kmeans) throws IOException {
		boolean done = false;
		int retry = 0;
		Point[] clusterMeans = new Point[kmeans];
		FileSystem fs = FileSystem.get(conf);
		
		for (FileStatus f : fs.listStatus(new Path(conf.get("meansStringPath")))) {
			while (!done && retry < 5) {
				try {
					// read a line from the path direction
					LineReader reader = new LineReader(fs.open(f.getPath()));
					Text clusterMeanText = new Text();
					reader.readLine(clusterMeanText);
					
					// parse the line into its index number and a coordinates string to store as a Point
					String clusterMeanString = clusterMeanText.toString();
					String[] clusterMeanValues = clusterMeanString.split("+\\s");
					int clusterIndex = Integer.parseInt(clusterMeanValues[0]);
					for (int i = 1; i < clusterMeanValues.length; i++) {
						clusterMeanString = clusterMeanString + " " + clusterMeanValues[i];
					}
					clusterMeans[clusterIndex] = new Point(clusterMeanString);
					
					// close this file
					reader.close();
				} catch (EOFException e) { // in case of failure, retry to read the file for a max. of 5 times
					done = false;
					retry++;
				}
			}
			if (retry >= 5) {
				retry = 0;
			}
		}
		
		return clusterMeans;
	}
	
	/**
	 * Run an iteration of the k-means clustering algorithm as a
	 *  Map/Reduce job
	 * @param conf: Configuration object used for every Map/Reduce job initiated 
	 * @param inputString: the input path as a String
	 * @param outputString: the output path as a String
	 * @param kmeans: the number of clusters to create as an Integer
	 * @param iterations: the number of iterations to run the algorithm as an Integer
	 * @return: a Point array, containing all the new centroids found
	 * @throws IOException for creating and starting a job, setting the input path
	 * 				and checking convergence
	 * @throws InterruptedException for starting a job
	 * @throws ClassNotFoundException for starting a job
	 */
	public Point[] doRound(Configuration conf, String inputString, String outputString, int kmeans, int iteration) throws IOException, InterruptedException, ClassNotFoundException {
		Job phase1 = new Job(conf, "KMeans - Iteration " + (iteration + 1)); // Main settings
		phase1.setJarByClass(Pagerank.class);
		FileInputFormat.setInputPaths(phase1, new Path(inputString)); // Input settings
		phase1.setInputFormatClass(TextInputFormat.class);
		FileOutputFormat.setOutputPath(phase1, new Path(outputString)); // Output settings
		phase1.setOutputFormatClass(TextOutputFormat.class);
		phase1.setOutputKeyClass(IntWritable.class);
		phase1.setOutputValueClass(Point.class);
		phase1.setMapperClass(Map.class); // Class settings
		phase1.setReducerClass(Reduce.class);
		phase1.setNumReduceTasks(kmeans);
		
		long startTime = System.currentTimeMillis();
		if (phase1.waitForCompletion(true)) {
			System.out.println("Iteration " + (iteration + 1) + " Finished in " + (System.currentTimeMillis() - startTime) / 1000.0 + " seconds");
		}
		
		return getCalculatedMeans(conf, kmeans);
	}
	
	/**
	 * Iterate the main map/reduce job of:
	 *  1. Calculating distances between cluster centroids and the points
	 *  2. Recalculating the new cluster centroids
	 * If it is the first iteration, start by setting a flag in the 
	 * 	Configuration object 
	 * After a round was finished, check if the centroids converged (e.g. they equal the previous round)
	 * @param conf: Configuration object used for every Map/Reduce job initiated 
	 * @param inputString: the input path as a String
	 * @param baseOutputString: the base path as a String to put all the output in
	 * @param kmeans: the number of clusters to create as an Integer
	 * @param iterations: the number of iterations to run the algorithm as an Integer
	 * @throws Exception from the doRound() method
	 */
	private void iterate(Configuration conf, String inputString, String baseOutputString, int kmeans, int iterations) throws Exception {
		String meanOutputString = "";
		Point[] previousMeans = new Point[0], currentMeans = new Point[kmeans];
		
		System.out.printf("Matrix Input Path: %s Base Output Path: %s Iterations: %d\n", inputString, baseOutputString, iterations);
		for (int i = 0; i < iterations; i++) {
			System.out.printf("Iteration %d will start\n\n;", i + 1);
			if (i == 0) {
				conf.setBoolean("FirstIteration", true);
			}
			else {
				conf.setBoolean("FirstIteration", false);
			}
			meanOutputString = baseOutputString + "/iter" + i;
			currentMeans = doRound(conf, inputString, meanOutputString, kmeans, i);
			System.out.printf("\n\nIteration %d complete\n\n", i + 1);
			
			if (checkConvergence(previousMeans, currentMeans)) {
				break;
			}
			else {
				previousMeans = currentMeans;
			}
		}
	}
	
	/**
	 * Prints out the usages of this program in case the user
	 *  gave incorrect input
	 * @param numArgs: number of arguments in the String array object
	 */
	private int printUsage() {
		System.out.println("usage:\t <input path> <output path> <k mean points> <number of iterations>");
		ToolRunner.printGenericCommandUsage(System.out);
		return -1;
	}
	
	/**
	 * Runs the main program
	 * 
	 * @param args: String array of arguments given at start 
	 * @return -1 in case of error | 0 in case of success
	 * @throws Exception from the iterate() method
	 */
	@Override
	public int run(String[] args) throws Exception {
		int iterations = 0, kmeans = 0;
		String inputString = "", outputString = "";
		Configuration conf = new Configuration(getConf());
		
		// Set arguments
		if (args.length < 4) {
			System.err.println("Error: too few parameters given");
			return printUsage();
		}
		inputString = args[0];
		outputString = args[1];
		conf.set("meansStringPath", outputString + "/means"); // the path where to store the cluster means found
		try {
			kmeans = Integer.parseInt(args[2]);
			conf.setInt("NumKMeans", kmeans);
			iterations = Integer.parseInt(args[3]);
		} catch (NumberFormatException e) {
			System.err.println("Error: expected Integers instead of " + args[2] + " (arg 2) and " + args[3] + " (arg 3)");
			return printUsage();
		}
		
		// Create and start iterations
		iterate(conf, inputString, outputString, kmeans, iterations);
		return 0;
	}
	
	public static void main(String[] args) throws Exception {
		int result = ToolRunner.run(new Configuration(), new Pagerank(), args);
		System.exit(result);
	}
}
