package nl.vu.cs.cn;

import java.io.IOException;
import java.nio.ByteBuffer;
import java.nio.ByteOrder;
import java.util.Random;

import nl.vu.cs.cn.IP.IpAddress;
import nl.vu.cs.cn.IP.Packet;

/**
 * This class represents a TCP stack Implementation. 
 * It should be built on top of the IP stack
 *  which is bound to a given IP address.
 *  
 * This class is used for our TCP Tests and is wrapped 
 *  by the 'TCP' class, because our test suite requires 
 *  the majority methods to be public
 *  
 * @author Steven van Beelen, 1821806
 *  and Gerben Rozie, 1821954
 */
public class TCPImplementation {
	
	public static final byte FIN = 0x01, // The FIN(finish) byte flag
			SYN = 0x02, // The SYN(synchronize) byte flag
			PSH = 0x08, // The PSH(push) byte flag
			ACK = 0x10; // The ACK(acknowledge) byte flag
	public static final int TIMEOUT = 1, // Timeout for receiving an acknowledgment in seconds.
			NUM_RETRANSMISSION = 10; // Number of times a send may be resent in case of error.
	public static boolean DEBUG = false; // Flag denoting if you want debug prints on or off
	
	public IP ip; // The underlying IP stack for this TCP stack.
	public TCB tcb; // The Transmission Control Block for this TCP stack.
	
	/****************************************************************************************
	 *                              Connecting/Socket Class/Methods                         *
	 ****************************************************************************************/
	
	/**
	 * This class represents a TCP socket.
	 */
	public class SocketImplementation {
		
		public static final int DEFAULT_PORT = 12345; // The default port number used for client TCP stacks
		
		public int port;
		
		/**
		 * Construct a client socket.
		 */
		public SocketImplementation() {
			port = DEFAULT_PORT;
		}
		
		/**
		 * Construct a server socket bound to the given local port.
		 *
		 * @param port the local port to use
		 */
		public SocketImplementation(int port) {
			this.port = port;
		}
		
		/**
		 * Connect this socket to the specified destination and port.
		 * The client will perform a connect request
		 * 
		 * The TCB is already set here and will be filled with the given
		 *  dest_ipaddr, port, source(send) sequence number and the
		 *  new state.
		 *
		 * @param dest_ipaddr the destination to connect to
		 * @param port the port to connect to
		 * @return true if the connect succeeded
		 * 	false if the state was incorrect, if dest_ipaddr
		 *  was not filled, if port was not filled, if sending
		 *  the SYN packet (first step of handshake) failed and 
		 *  if sending the ACK packet (third step of handshake) failed 
		 */
		public boolean connect(IpAddress dest_ipaddr, int port) {
			int bytesSent = 0;
			if (!tcb.state.equals(ConnectionState.CLOSED)) {
				errorMessage(1);
				return false;
			}
			
			tcb.src_port = (short) this.port;
			if (dest_ipaddr == null) {
				System.err.println("Error: foreign address unspecified");
				return false;
			}
			tcb.dest_ipaddr = dest_ipaddr;
			if (port < 0) {
				System.err.println("Error: foreign socket unspecified");
				return false;
			}
			tcb.dest_port = (short) port;
			tcb.src_seqnum = tcb.isseqnum;
			tcb.state = ConnectionState.SYN_SENT;
			
			debugPrinter("CONNECT:%d Trying to send SYN packet... | State: %s\n", tcb.src_port, tcb.state);
			bytesSent = send_syn(); // 1 step of 3-way-handshake
			if (bytesSent == -1) {
				tcb.clean();
				return false; // Connecting failed since SYN sending failed | clean() sets state to CLOSED
			}
			else if (tcb.state.equals(ConnectionState.ESTABLISHED)) {
				debugPrinter("CONNECT:%d Sending SYN packet succesfull, send ACK packet in response to SYNACK... | State: %s\n", tcb.src_port, tcb.state);
				bytesSent = send_ack(); // Step 3 of 3-way-handshake (ACK)
				if (bytesSent == -1) {
					tcb.clean();
					return false; // Connecting failed since ACK sending failed | clean() sets state to CLOSED
				}
				debugPrinter("CONNECT:%d Sending ACK packet was succesfull | State: %s\n", tcb.src_port, tcb.state);
			}
			return true;
		}
		
		/**
		 * Accept a connection on this socket.
		 * This call blocks until a connection is made.
		 * The server will wait in the accept method for a connect request
		 * 
		 * Tries to establish a connection with another party through busy 
		 *  waiting on recv_tcp_packet within a while loop
		 * If a connection request comes in and the sending of the SYNACK 
		 *  (second step of handshake) fails, the method will retry
		 * Additionally, if the state is not CLOSED, we will not accept new connection
		 *  and will thus return.
		 */
		public void accept() {
			int bytesSent = 0;
			if (!tcb.state.equals(ConnectionState.CLOSED)) {
				errorMessage(1);
				return;
			}
			tcb.src_port = (short) port;
			tcb.state = ConnectionState.LISTEN;
			
			// Busy waiting/blocking on receiving a connection request
			while (!tcb.state.equals(ConnectionState.ESTABLISHED)) {
				debugPrinter("ACCEPT:%d Checking for Connection request packets... | State: %s\n", tcb.src_port, tcb.state);
				recv_tcp_packet(true); // Call blocks on receive, be retrying all the time
				if (tcb.state.equals(ConnectionState.SYN_RCVD)) {
					debugPrinter("ACCEPT:%d Received Connection request, respond with sending SYNACK packet... | State: %s\n", tcb.src_port, tcb.state);
					tcb.src_seqnum = tcb.isseqnum;
					bytesSent = send_syn();// 2 step of 3-way-handshake (SYNACK)
					if (bytesSent == -1) {
						debugPrinter("ACCEPT:%d Sending SYNACK packet was unsuccesful | State: %s\n", tcb.src_port, tcb.state);
						tcb.state = ConnectionState.LISTEN;
						continue; // Connecting failed, retry
					}
					debugPrinter("ACCEPT:%d Sending SYNACK packet was succesfull | State: %s\n", tcb.src_port, tcb.state);
				}
			}
		}
		
		/**
		 * Writes to the socket from the buffer.
		 * 
		 * Will try to write the buffer it has in maximum 
		 *  chunk sizes, until there is not data left, within
		 *  a while block. 
		 * The offset for copying the data from the
		 *  given buffer to the data packet is moved
		 *  according to the number of bytes written, as well as
		 *  the data_left variable. This happens every loop of the
		 *  while block.
		 * When the leave the while block, a check is performed to see
		 *  whether any data was sent.
		 *
		 * @param buf the buffer to send
		 * @param offset the offset to begin writing data from
		 * @param len the number of bytes to write
		 * @return the number of bytes written, 
		 *  which equals the len variable minus the data which is still left 
		 *  or -1 if an error occurs
		 * Errors are incorrect state for writing or no data was sent at all
		 */
		public int write(byte[] buf, int offset, int len) {
			int dataSize = 0, bytesSent = 0;
			if (!tcb.state.equals(ConnectionState.ESTABLISHED) && !tcb.state.equals(ConnectionState.CLOSE_WAIT)) {
				errorMessage(2);
				return -1; // Not in a state to write data
			}
			if (len > buf.length) {
				tcb.data_left = buf.length;
			}
			else {
				tcb.data_left = len;
			}
			
			debugPrinter("WRITE:%d Trying to write data...\n\tVariables: buf.length: %d\toffset: %d\tlen: %d\ttcb.data_left: %d\n", tcb.src_port, buf.length, offset, len, tcb.data_left);
			while (tcb.data_left > 0) { // Working through the array until all packets have been send
				dataSize = Math.min(tcb.data_left, TCB.BUF_SIZE);
				tcb.packet_data = new byte[dataSize];
				System.arraycopy(buf, offset, tcb.packet_data, 0, dataSize);
				
				debugPrinter("WRITE:%d Buffer copied into tcb.packet_data, will now send Data packet...\n\tVariables: dataSize: %d\ttcb.packet_data.length: %d\ttcb.data_left: %d\toffset: %d\n", tcb.src_port, dataSize, tcb.packet_data.length, tcb.data_left, offset);
				bytesSent = send_data(); // The actual sending from the socket to the tcp stack				
				if (bytesSent < 20) { //A data packet should be at least 0 byte large, but first the tcpheader should be removed from the bytes sent
					debugPrinter("WRITE:%d Sending data was unsuccesful\n", tcb.src_port);
					break;
				}
				
				tcb.data_left -= bytesSent - 20; //Data left becomes decremented with the bytes sent, minus the tcp header
				offset += bytesSent - 20; //The offset becomes increment with the bytes sent, minus the tcp header
				debugPrinter("WRITE:%d Sending data was succesfull; %d bytes were sent\n\tVariables: dataleft: %d\toffset: %d\n", tcb.src_port, bytesSent, tcb.data_left, offset);
			}
			
			if (tcb.data_left == len) { //Check wether any data was send
				debugPrinter("WRITE:%d Writing data was unsuccesful| data_left(%d) == len(%d), hence nothing was written\n", tcb.src_port, tcb.data_left, len);
				System.err.println("Error: sending data failed");
				return -1;
			}
			debugPrinter("WRITE:%d Writing data was succesfull | Wrote %d bytes\n", tcb.src_port, len - tcb.data_left);
			return len - tcb.data_left;
		}
		
		/**
		 * Reads bytes from the socket into the buffer.
		 * This call is not required to return maxlen bytes
		 *  every time it returns.
		 * 
		 * Read will try to receive a data packet ten times, in case
		 *  a corrupt data packet has come in or something different
		 *  then data was returned.
		 * If the state was incorrect or the copying of the data into
		 *  the buffer failed, -1 will be returned.
		 *
		 * @param buf: the buffer to copy the data into
		 * @param offset: the offset to begin reading data into the buffer
		 * @param maxlen: the maximum number of bytes to read into the buffer
		 * @return the number of bytes read minus twenty for the TCP header
		 *  and -1 in case of error
		 */
		public int read(byte[] buf, int offset, int maxlen) {
			int bytesRead = 0, numRetries = NUM_RETRANSMISSION;
			if (!tcb.state.equals(ConnectionState.ESTABLISHED) && !tcb.state.equals(ConnectionState.FIN_WAIT_1) &&
					!tcb.state.equals(ConnectionState.FIN_WAIT_2) && !tcb.state.equals(ConnectionState.CLOSE_WAIT)) {
				errorMessage(3);
				return -1; // Not in state to read data
			}
			
			debugPrinter("READ:%d Trying to read data...\n\tVariables: buf.length: %d\toffset: %d\tmaxlen: %d\n", tcb.src_port, buf.length, offset, maxlen);
			while (numRetries != 0 && !tcb.state.equals(ConnectionState.TIME_WAIT)) {
				bytesRead = recv_tcp_packet(true);
				if (bytesRead > 0) {
					break;
				}
			}
			debugPrinter("READ:%d Reading data was succesfull | Going to copy the data into the buffer...\n", tcb.src_port);
			try { // Should write to the buffer at point offset and should read this data from data buffer at the start/zero. Max to read should be the length of the data buffer 
				debugPrinter("READ:%d Copy variables: buf.length: %d\toffset: %d\tmaxlen: %d\tdata.len: %d\n", tcb.src_port, buf.length, offset, maxlen, tcb.data.length);
				System.arraycopy(tcb.data, 0, buf, offset, tcb.data.length);
//				if(maxlen > tcb.data.length){
//					System.arraycopy(tcb.data, 0, buf, offset, tcb.data.length);
//				}
//				else {
//					System.arraycopy(tcb.data, 0, buf, offset, maxlen);
//				}
			} catch (Exception e) {
				e.printStackTrace();
				System.err.println("Error: moving data to buffer failed");
				return -1;
			}
			debugPrinter("READ:%d Copying data in the buffer was succesfull | Sending ACK packet of the data read...\n", tcb.src_port);
			send_ack(); // Send acknowledgment for the received data 
			debugPrinter("READ:%d Sending ACK packet was succesfull | Reading is finished\n", tcb.src_port);
			
			return bytesRead - 20; // Returned the number of bytes read minus the tcp header length of 20
		}
		
		/**
		 * Closes the connection for this socket.
		 * Blocks until the connection is closed.
		 * 
		 * If the state is LISTEN or SYN_SENT, we may 
		 *  directly kill the connection, but will only start 
		 *  sending a FIN packet if the  state equals SYN_RCVD, 
		 *  ESTABLISHED or CLOSE_WAIT
		 * When FIN sending was correct, the state will move to
		 *  FIN_WAIT_2 or CLOSING. From FIN_WAIT_2, we will wait
		 *  endlessly until a FIN is received, because we should
		 *  accept data in this state.
		 *  From CLOSING we wait a maximum of ten times for 
		 *  receiving an ACK, since we should only be able to
		 *  receive ACKs from here and the maximum retries of 
		 *  re-sending is also ten.
		 *
		 * @return true unless no connection was open. 
		 */
		public boolean close() {
			int bytesSent = 0, numRetries = NUM_RETRANSMISSION;
			if (!tcb.state.equals(ConnectionState.LISTEN) && !tcb.state.equals(ConnectionState.SYN_SENT) &&
					!tcb.state.equals(ConnectionState.SYN_RCVD) && !tcb.state.equals(ConnectionState.ESTABLISHED) &&
					!tcb.state.equals(ConnectionState.CLOSE_WAIT)) {
				debugPrinter("CLOSE:%d Connection was already closed\n", tcb.src_port);
				errorMessage(4);
				return false; // Already closed
			}
			debugPrinter("CLOSE:%d Trying to close connection...\n", tcb.src_port);
			
			if (tcb.state.equals(ConnectionState.LISTEN) || tcb.state.equals(ConnectionState.SYN_SENT)) {
				debugPrinter("CLOSE:%d Closing connection was succesfull | State: %s\n", tcb.src_port, tcb.state);
				tcb.clean();
			}
			else if (tcb.state.equals(ConnectionState.SYN_RCVD) || tcb.state.equals(ConnectionState.ESTABLISHED)) {
				debugPrinter("CLOSE:%d Trying to send FIN packet... | State: %s\n", tcb.src_port, tcb.state);
				ConnectionState previousState = tcb.state; // Keep previous state so it can return to this state if closing fails
				tcb.state = ConnectionState.FIN_WAIT_1;
				
				bytesSent = send_fin();
				if (bytesSent == -1) {
					tcb.state = previousState; // Return to previous state since closing was unsuccessful
					debugPrinter("CLOSE:%d Sending FIN packet was unsuccesful | State: %s\n", tcb.src_port, tcb.state);
					return true; // Sending FIN packet failed
				}
				debugPrinter("CLOSE:%d Sending FIN packet was succesfull | State: %s\n", tcb.src_port, tcb.state);
				
				// Received ACK in FIN_WAIT_1 | Regular Close
				if (tcb.state.equals(ConnectionState.FIN_WAIT_2)) { 
					debugPrinter("CLOSE:%d FIN packet was responded with an ACK | State: %s\n CLOSE:%d Wait for following FIN packet...", tcb.src_port, tcb.state);
					while (!tcb.state.equals(ConnectionState.TIME_WAIT)) {
						// Loop until a FIN was received | if a FIN packet was received, the code will mode to TIME_WAIT and thus move out of the loop
						recv_tcp_packet(true); //Receive closing FIN packet from other party
					}
					debugPrinter("CLOSE:%d Receiving FIN packet was succesful, send ACK packet in response... | State %s\n", tcb.src_port, tcb.state);
					
					bytesSent = send_ack(); // Send ACK packet in reply to FIN packet 
					if (bytesSent == -1) {
						debugPrinter("CLOSE:%d Sending ack was unsuccesful...state: %s\n", tcb.src_port, tcb.state);
						tcb.state = previousState; // Return to previous state since closing was unsuccessful
						return true; // Failed to send LAST_ACK to Server
					}
					debugPrinter("CLOSE:%d Sending ack should have ben succesfull | state: %s\n", tcb.src_port, tcb.state);
				} // Received FIN in FIN_WAIT_1 | Simultaneous Close
				else if (tcb.state.equals(ConnectionState.CLOSING)) {
					debugPrinter("CLOSE:%d FIN packet was responded with a FIN | State: %s\n CLOSE:%d Wait for following ACK packet...", tcb.src_port, tcb.state);
					tcb.dest_seqnum -= 1; // If we don't decrement our destination sequence number (the acknum we send), the recv_tcp_packet will fail receiving the final ack from the Reference tests
					while (numRetries != 0 && !tcb.state.equals(ConnectionState.TIME_WAIT)) {
						recv_tcp_packet(true); //Wait for ACK, recv_ack() will push it to state TIME_WAIT
						if (!tcb.state.equals(ConnectionState.TIME_WAIT)) {
							numRetries--;
							debugPrinter("CLOSE:%d Receiving ACK packet was unsuccesful, will retry | Retry: %d\tState: %s\n", tcb.src_port, NUM_RETRANSMISSION - numRetries, tcb.state);
						}
					}
					debugPrinter("CLOSE:%d Receiving ACK packet was succesful | State: %s\n", tcb.src_port, tcb.state);
				}
			}
			else if (tcb.state.equals(ConnectionState.CLOSE_WAIT)) {
				debugPrinter("CLOSE:%d Trying to send FIN packet... | State: %s\n", tcb.src_port, tcb.state);
				tcb.state = ConnectionState.LAST_ACK;
				bytesSent = send_fin();
				if (bytesSent == -1) {
					debugPrinter("CLOSE:%d Sending FIN packet was unsuccesful | State: %s\n", tcb.src_port, tcb.state);
					tcb.state = ConnectionState.CLOSE_WAIT; // Return to previous state since closing was unsuccessful
					return true; // Failed to send FIN packet
				}
				debugPrinter("CLOSE:%d Sending FIN packet was succesfull | State: %s\n", tcb.src_port, tcb.state);
			}
			
			if (tcb.state.equals(ConnectionState.TIME_WAIT)) {
				try {
					debugPrinter("CLOSE:%d Connection almost closed, waiting for Timeout...\n", tcb.src_port);
					Thread.sleep(TIMEOUT * 1000);
					debugPrinter("CLOSE:%d Closing connection was succesfull\n", tcb.src_port);
				} catch (InterruptedException e) {
					e.printStackTrace();
				}
				tcb.clean();
			}
			else {
				debugPrinter("CLOSE:%d Closing connection was unsuccesful | State: %s\n", tcb.src_port, tcb.state);
			}
			
			return true;
		}
		
		/**
		 * Helper method to call an error message from
		 * 
		 * @param type: number indicating from which method the call originated
		 *  1 = listen() / accept(), 2 = write(),
		 *  3 = read() and 4 = close() 
		 */
		public void errorMessage(int type) {
			if (type == 1) { // From listen() / accept()
				System.err.println("Error: connection already exists");
			}
			else if (type == 2) { // From write()
				if (tcb.state.equals(ConnectionState.CLOSED)) {
					System.err.println("Error: connection does not exist");
				}
				if (tcb.state.equals(ConnectionState.LISTEN) || tcb.state.equals(ConnectionState.SYN_SENT) ||
						tcb.state.equals(ConnectionState.SYN_RCVD)) {
					System.err.println("Error: connection does not exist; still trying to connect");
				}
				if (tcb.state.equals(ConnectionState.FIN_WAIT_1) || tcb.state.equals(ConnectionState.FIN_WAIT_2) ||
						tcb.state.equals(ConnectionState.CLOSING) || tcb.state.equals(ConnectionState.LAST_ACK) ||
						tcb.state.equals(ConnectionState.TIME_WAIT)) {
					System.err.println("Error: connection closing");
				}
			}
			else if (type == 3) { // From read()
				if (tcb.state.equals(ConnectionState.CLOSED)) {
					System.err.println("Error: connection does not exist");
				}
				if (tcb.state.equals(ConnectionState.LISTEN) || tcb.state.equals(ConnectionState.SYN_SENT) ||
						tcb.state.equals(ConnectionState.SYN_RCVD)) {
					System.err.println("Error: connection does not exist; still trying to connect");
				}
				if (tcb.state.equals(ConnectionState.CLOSING) || tcb.state.equals(ConnectionState.LAST_ACK) ||
						tcb.state.equals(ConnectionState.TIME_WAIT)) {
					System.err.println("Error: connection closing");
				}
			}
			else if (type == 4) { // From close()
				if (tcb.state.equals(ConnectionState.CLOSED)) {
					System.err.println("Error: connection does not exist");
				}
				if (tcb.state.equals(ConnectionState.FIN_WAIT_1) || tcb.state.equals(ConnectionState.FIN_WAIT_2) ||
						tcb.state.equals(ConnectionState.CLOSING) || tcb.state.equals(ConnectionState.LAST_ACK) ||
						tcb.state.equals(ConnectionState.TIME_WAIT)) {
					System.err.println("Error: connection closing");
				}
			}
			else { // Should be unreachable
				System.err.println("Error: trying to send unknown error");
			}
		}
	}
	
	/**
	 * Constructs a TCP stack for the given virtual address.
	 * The virtual address for this TCP stack is then
	 * 192.168.1.address.
	 *
	 * @param address: Integer storing the last octet of the virtual IP address (1-254)
	 * @throws IOException: if the IP stack fails to initialize.
	 */
	public TCPImplementation(int address) throws IOException {
		ip = new IP(address);
		tcb = new TCB(ip.getLocalAddress());
		tcb.isseqnum = new Random().nextInt(255); // Initialization of the source sequence number with a random Integer
	}
	
	/**
	 * Default Socket constructor
	 * 
	 * @return a new socket for this stack
	 */
	public SocketImplementation socket() {
		return new SocketImplementation();
	}
	
	/**
	 * Construct a Socket Object with given 
	 *  port number
	 * 
	 * @return a new server socket for this stack bound to the given port
	 * @param port the port to bind the socket to.
	 */
	public SocketImplementation socket(int port) {
		return new SocketImplementation(port);
	}
	
	/****************************************************************************************
	 *                                  Sending Methods                                     *
	 ****************************************************************************************/
	
	/**
	 * Method to send a 'synchronize'(SYN) packet to the destination port
	 * 
	 * @return the number of bytes sent as an integer
	 *  -1 in case of failed sending and bytesSent in case packet is received
	 */
	public int send_syn() {
		int bytesSent = 0, bytesRead = 0, numRetransmission = NUM_RETRANSMISSION;
		byte flags = (byte) 0;
		debugPrinter("SEND_SYN:%d Entered send_syn() method\n", tcb.src_port);
		if (tcb.state.equals(ConnectionState.SYN_SENT)) {
			flags = PSH | SYN; // Connect calls send_syn
		}
		else if (tcb.state.equals(ConnectionState.SYN_RCVD)) {
			flags = PSH | SYN | ACK; // Accept calls send_syn
		}
		else { // Not in the states LISTEN or CLOSED, hence inappropriate method access
			System.err.println("Error: not in state LISTEN or CLOSED\n\tcannot send a SYN packet");
			return -1;
		}
		
		while (numRetransmission > 0) {
			debugPrinter("SEND_SYN:%d Trying to send SYN packet... | Try: %d\tSeqnum: %d\tAcknum: %d\n", tcb.src_port, NUM_RETRANSMISSION + 1 - numRetransmission, tcb.src_seqnum, tcb.dest_seqnum);
			bytesSent = send_tcp_packet(tcb.dest_ipaddr, tcb.dest_port, tcb.src_port, tcb.src_seqnum, tcb.dest_seqnum, flags, (short) 0, new byte[0], 0);
			if (bytesSent == -1) {
				System.err.printf("Error: sending SYN packet failed");
				return -1;
			}
			else {
				/** 
				 * Our sequence number will be increased to ISS + 1, the seqnum
				 *  we will use on our next message
				 * Expected_acknum set to ISS, since that is what we at least
				 *  expect to be acknowledged
				 **/
				tcb.expected_acknum = (tcb.isseqnum + 1) % Integer.MAX_VALUE;
			}
			debugPrinter("SEND_SYN:%d Sending SYN packet was succesful | isseqnum: %d src_seqnum: %d expected_acknum: %d\n", tcb.src_port, tcb.isseqnum, tcb.src_seqnum, tcb.expected_acknum);
			
			bytesRead = recv_tcp_packet(true); // CONNECT: Receiving the SYNACK for the connection request ACCEPT: Receiving the ACK for the SYN send
			if (bytesRead > 0 && received_all_acks()) {
				debugPrinter("SEND_SYN:%d Receiving (SYN)ACK was succesfull | State: %s\n", tcb.src_port, tcb.state);
				return bytesSent;
			}
			debugPrinter("SEND_SYN:%d Sending SYN packet was unsuccesful\n\tVariables: bytesRead: %d | src_seqnum %d == expected_acknum %d\n", tcb.src_port, bytesRead, tcb.src_seqnum, tcb.expected_acknum);
			numRetransmission--;
		}
		System.err.printf("Error: sending SYN packet failed ten times");
		return -1;
	}
	
	/**
	 * Method to send an 'acknowledgement'(ACK) message to the destination port
	 * 
	 * @return the number of bytes sent as an integer
	 */
	public int send_ack() {
		int bytesSent = 0, numRetransmission = NUM_RETRANSMISSION;
		byte flags = PSH | ACK;
		debugPrinter("SEND_ACK:%d Entered send_ack() method\n", tcb.src_port);
		
		while (numRetransmission > 0) {
			debugPrinter("SEND_ACK:%d Trying to send ACK packet... | Try: %d\tSeqnum: %d\tAcknum: %d\n", tcb.src_port, NUM_RETRANSMISSION + 1 - numRetransmission, tcb.src_seqnum, tcb.dest_seqnum);
			bytesSent = send_tcp_packet(tcb.dest_ipaddr, tcb.dest_port, tcb.src_port, tcb.src_seqnum, tcb.dest_seqnum, flags, (short) 0, new byte[0], 0);
			if (bytesSent >= 0) {
				debugPrinter("SEND_ACK:%d Sending ACK packet was succesful | src_seqnum: %d\n", tcb.src_port, tcb.src_seqnum);
				break;
			}
			debugPrinter("SEND_ACK:%d Sending ACK packet was unsuccesful\n\tVariables: bytesSent: %d\n", tcb.src_port, bytesSent);
			numRetransmission--;
		}
		if (numRetransmission == 0) {
			System.err.printf("Error: sending ACK packet failed ten times");
			return -1;
		}
		return bytesSent;
	}
	
	/**
	 * Method to send a data message to the destination port
	 * 
	 * @return the number of bytes sent as an integer
	 */
	public int send_data() {
		int bytesSent = 0, bytesRead = 0, dataSize = tcb.packet_data.length, numRetransmission = NUM_RETRANSMISSION;
		byte flags = PSH;
		debugPrinter("SEND_DATA:%d Entered send_data() method\n", tcb.src_port);
		if (!tcb.state.equals(ConnectionState.ESTABLISHED) && !tcb.state.equals(ConnectionState.CLOSE_WAIT)) {
			System.err.println("Error: not in state ESTABLISHED or CLOSE_WAIT\n\tcannot send a data packet");
			return -1; // Not in the states ESTABLISHED or CLOSE_WAIT, hence inappropriate method access
		}
		
		while (numRetransmission > 0) {
			debugPrinter("SEND_DATA:%d Trying to send data packet... | Try: %d\tSeqnum: %d\tAcknum: %d\n", tcb.src_port, NUM_RETRANSMISSION + 1 - numRetransmission, tcb.src_seqnum, tcb.dest_seqnum);
			bytesSent = send_tcp_packet(tcb.dest_ipaddr, tcb.dest_port, tcb.src_port, tcb.src_seqnum, tcb.dest_seqnum, flags, (short) 0, tcb.packet_data, dataSize);
			if (bytesSent == -1) {
				System.err.printf("Error: sending data packet failed");
				return -1;
			}
			else if (numRetransmission == NUM_RETRANSMISSION) {
				// Expected acknum should equal what we want them to acknowledge
				tcb.expected_acknum = (tcb.src_seqnum + bytesSent - 20) % Integer.MAX_VALUE;
				debugPrinter("SEND_DATA:%d Sending data was succesfull\n\t" +
						"src_seqnum: %d expected_acknum: %d\n", tcb.src_port, tcb.src_seqnum, tcb.expected_acknum);//TODO remove print
			}
			debugPrinter("SEND_DATA:%d Will now try to receive an ACK to our data send\n", tcb.src_port);
			
			bytesRead = recv_tcp_packet(true); // Receiving the acknowledgement that the data has arrived
			if (bytesRead > 0 && received_all_acks()) {
				debugPrinter("SEND_DATA:%d Sending data was succesfull\n", tcb.src_port);
				return bytesSent;
			}
			debugPrinter("SEND_DATA:%d Sending data packet was unsuccesful\n\tVariables: bytesRead: %d | src_seqnum %d == expected_acknum %d\n", tcb.src_port, bytesRead, tcb.src_seqnum, tcb.expected_acknum);
			numRetransmission--;
		}
		System.err.printf("Error: sending data packet failed ten times");
		return -1;
	}
	
	/**
	 * Method to send a 'finish'(FIN) request message to the destination port
	 * 
	 * @return the number of bytes sent as an integer
	 */
	public int send_fin() {
		int bytesSent = 0, bytesRead = 0, numRetransmission = NUM_RETRANSMISSION;
		byte flags = PSH | FIN | ACK;
		debugPrinter("SEND_FIN:%d Entered send_fin() method\n", tcb.src_port);
		if (!tcb.state.equals(ConnectionState.FIN_WAIT_1) && !tcb.state.equals(ConnectionState.LAST_ACK)) {
			// Not in the states FIN_WAIT_1 or LAST_ACK, hence inappropriate method access
			System.err.println("Error: not in state FIN_WAIT_1 or LAST_ACK\n\tcannot send a FIN packet");
			return -1;
		}
		
		while (numRetransmission > 0) {
			debugPrinter("SEND_FIn:%d Trying to send FIN packet... | Try: %d\tSeqnum: %d\tAcknum: %d\n", tcb.src_port, NUM_RETRANSMISSION + 1 - numRetransmission, tcb.src_seqnum, tcb.dest_seqnum);
			bytesSent = send_tcp_packet(tcb.dest_ipaddr, tcb.dest_port, tcb.src_port, tcb.src_seqnum, tcb.dest_seqnum, flags, (short) 0, new byte[0], 0);
			if (bytesSent == -1) {
				System.err.printf("Error: sending FIN packet failed");
				return -1;
			}
			else if (numRetransmission == NUM_RETRANSMISSION) {
				tcb.expected_acknum = (tcb.src_seqnum + 1) % Integer.MAX_VALUE; // Expected acknum should equal what we want them to acknowledge
			}
			
			bytesRead = recv_tcp_packet(true);
			if (bytesRead > 0 && (received_all_acks() || tcb.state.equals(ConnectionState.CLOSING))) {
				debugPrinter("SEND_FIN:%d packet in response to FIN packet received\n\tshould have been an ACK or a FIN\n", tcb.src_port);//TODO remove
				/** Receiving the acknowledgement that the fin has arrived */
				return bytesSent;
			}
			debugPrinter("SEND_FIN:%d Sending FIN packet was unsuccesful\n\tVariables: bytesRead: %d | src_seqnum %d == expected_acknum %d\n", tcb.src_port, bytesRead, tcb.src_seqnum, tcb.expected_acknum);
			numRetransmission--;
		}
		System.err.printf("Error: sending FIN packet failed ten times");
		return -1;
	}
	
	/**
	 * Base sending method of tcp packets
	 * 
	 * @param dest_ipaddr: The destination IP address to send to
	 * @param dest_port: The port to which the packet will be send
	 * @param src_port: The port from which the packet will originate
	 * @param seqnum: The sequence number for this packet
	 * @param acknum: The acknowlegde number for this packet
	 * @param flags: The flags for this packet
	 * @param window_size: The windows size for this packet (not used)
	 * @param data: The data which this packet will send
	 * @param data_size: The size of the data in this packet
	 * @return The number of bytes send as an integer
	 *  -1 in case of error and 0 or higher in case of success
	 */
	public int send_tcp_packet(IpAddress dest_ipaddr, short dest_port, short src_port, int seqnum, int acknum, byte flags, short window_size, byte[] data, int data_size) {
		int bytesSent;
		short checksum = 0;
		short urg_pointer = 0;
		//byte data_offset = 0x50;//TODO correct offset?
		byte data_offset = 0x05;//TODO correct offset?
		/** The data starts after 20 bytes permenantly, since we do not use any options */
		
		TcpHeader tcpHead = new TcpHeader(src_port, dest_port, seqnum, acknum, data_offset, flags, window_size, checksum, urg_pointer);
		//tcpHead.data_offset = (byte) tcpHead.length();
		TcpSegment tcpSeg = new TcpSegment(tcpHead, data);
		PseudoHeader ph = new PseudoHeader(ip.getLocalAddress(), dest_ipaddr, (byte) 0, (byte) IP.TCP_PROTOCOL, tcpSeg.length());
		checksum = tcpSeg.computeChecksum(ph);
		debugPrinter("SND_TCP_PAC:%d Computed Checksum: %d and Complement of Computed Checksum: %d\n", tcb.src_port, checksum, (short) ~checksum);
		tcpSeg.setChecksum(checksum);
		
		Packet p = null;
		try {
			p = new Packet(dest_ipaddr.getAddress(), IP.TCP_PROTOCOL, 2, tcpSeg.getByteArray(), tcpSeg.length());
		} catch (IOException e1) {
			e1.printStackTrace();
			bytesSent = -1;
		}
		
		try {
			debugPrinter("SND_TCP_PAC:%d Sending packet...\n", tcb.src_port);//TODO Remove print
			bytesSent = ip.ip_send(p);
			debugPrinter("SND_TCP_PAC:%d Sent %d bytes (datalength + tcpheader) \n", tcb.src_port, bytesSent); //TODO Remove print
		} catch (IOException e) {
			e.printStackTrace();
			bytesSent = -1;
		}
		/** Return bytesSent - 20 for the TCP Header length, which is 20 bytes TODO changed this to removing the 20 in write and acknum setting respectively*/
		return bytesSent;
	}
	
	/****************************************************************************************
	 *                                  Receiving Methods                                   *
	 ****************************************************************************************/
	
	/**
	 * Base method to receive the ip packets
	 * 
	 * @param waitingReceive: boolean dictating the type of receive method used
	 * @return the number of bytes received as an integer
	 */
	public int recv_tcp_packet(boolean waitingReceive) {
		debugPrinter("RCV_TCP_PAC:%d State before receiving: %s\n", tcb.src_port, tcb.state);//TODO remove print
		Packet p = new Packet(0, 0, 0, new byte[0], 0);
		/** Initial empty packet to store incoming packet */
		TcpSegment s = new TcpSegment();
		PseudoHeader ph = new PseudoHeader();
		
		try {
			debugPrinter("RCV_TCP_PAC:%d Receiving packet...\n", tcb.src_port);//TODO remove print
			how_to_receive(p, waitingReceive);
			debugPrinter("RCV_TCP_PAC:%d Packet received...\n", tcb.src_port);//TODO remove print
		} catch (IOException e) {
			System.err.println("IO Error: IP layer failed to receive");
			debugPrinter("RCV_TCP_PAC:%d io ~\n", tcb.src_port); //TODO Remove print
			return -1;
		} catch (InterruptedException e) {
			System.err.println("Interrupted Error: IP layer failed to receive");
			debugPrinter("RCV_TCP_PAC:%d Timeout ~\n", tcb.src_port); //TODO Remove print
			return -1;
		}
		
		if (p.protocol != IP.TCP_PROTOCOL) {
			System.err.println("Error: incorrect protocol packet received");
			debugPrinter("RCV_TCP_PAC:%d incorrect protocol ~\n", tcb.src_port);
			return -1;
		}
		
		s = decodePacket(p);
		debugPrinter("RCV_TCP_PAC:%d After DecodePacket! s.length() = %d | s.data.length = %d\n", tcb.src_port, s.length(), s.data.length);
		/** Writes all packet info to a tcp segment */
		ph = new PseudoHeader(IP.IpAddress.getAddress(p.source), IP.IpAddress.getAddress(p.destination), (byte) 0, (byte) IP.TCP_PROTOCOL, s.length());
		
		debugPrinter("RCV_TCP_PAC:%d Will now validate the Checksum\n", tcb.src_port);
		if (!s.validateChecksum(ph)) {
			debugPrinter("RCV_TCP_PAC:%d Got invalid checksum...\n", tcb.src_port); //TODO Remove print
			return -1;
		}
		if (!correct_recvd_packet(s, ph)) {
			debugPrinter("RCV_TCP_PAC:%d Got incorrect packet...\n", tcb.src_port); //TODO Remove print
			return -1;
		}
		
		if (tcb.state.equals(ConnectionState.CLOSED)) {
			System.err.println("Error: no connection | cannot receive any messages");
			return -1;
		}
		else if (tcb.state.equals(ConnectionState.LISTEN) || tcb.state.equals(ConnectionState.SYN_SENT)) {
			/** Should only be able to receive a SYN/SYNACK here */
			if (recv_syn(s) > 0) {
				return s.length();
			}
			else {
				System.err.println("Error: didn't receive a correct SYN packet in LISTEN/SYN_SENT state");
				return -1;
			}
		}
		else if (s.tcpHeader.seqnum >= tcb.dest_seqnum) {
			/** 
			 * If in state SYN_RCVD, ESTABLISHED, FIN_WAIT_1, FIN_WAIT_2, CLOSE_WAIT
			 *  CLOSING, LAST_ACK or TIME_WAIT we may expect the messages can be sent in sequence
			 */
			//Comment for document.txt -> give reasoning for ordering of recv_* checks
			if (recv_syn(s) + recv_ack(s) + recv_fin(s) + recv_data(s) > 0) {
				debugPrinter("RCV_TCP_PAC:%d State after receiving: %s\n", tcb.src_port, tcb.state);//TODO remove print
				return s.length();
			}
			else {
				return -1;
			}
		}
		else {
			//			if (tcb.state.equals(ConnectionState.SYN_RCVD)) {
			//				return -1;
			//			}
			debugPrinter("RCV_TCP_PACK:%d After state and seqnum checking, those thus failed...\n" +
					"\tState: %s SegmentSeqnum: %d (>=) DestSeqnum %d" +
					"\tWill check if received an ack and will respond with sending an ACK\n",
					tcb.src_port, tcb.state, s.tcpHeader.seqnum, tcb.dest_seqnum);
			/** seqnum wasn't correct, hence ack to let them now you require another seqnum */
			tcb.dest_seqnum = s.tcpHeader.seqnum;
			send_ack();
			//TODO maybe send an ack from here (see end page 68 of RFC793), to make sure we acked their messages
			debugPrinter("RCV_TCP_PACK:%d Receiving and Sending ack in incorrect s.seqnum>=tcb.dest_seqnum state\n", tcb.src_port);
			System.err.println("Error: incorrect sequence numbering");
			return -1;
		}
	}
	
	/**
	 * Switching method between the ip_receive_timeout method
	 *  and the ip_receive method
	 * 
	 * @param p: The packet which will store the received information
	 * @param waitingReceive: the boolean which dictates if
	 *  ip_receive_timeout or ip_receive will be used
	 * @throws InterruptedException 
	 * @throws IOException 
	 */
	public void how_to_receive(Packet p, boolean waitingReceive) throws IOException, InterruptedException {
		if (waitingReceive) {
			ip.ip_receive_timeout(p, TIMEOUT);
		}
		else {
			ip.ip_receive(p);
		}
	}
	
	/**
	 * Method which decodes an incoming packet into a 
	 *  TCP segment
	 * 
	 * @param p: the received packet
	 * @return a TCP segment containing all the relevant data from the packet
	 */
	public TcpSegment decodePacket(Packet p) {
		short src_port = (short) 0;
		short dest_port = (short) 0;
		int seqnum = 0;
		int acknum = 0;
		byte data_offset = (byte) 0;
		byte flags = (byte) 0;
		short window_size = 0;
		short checksum = (short) 0;
		short urg_pointer = (short) 0;
		byte[] data = new byte[TCB.BUF_SIZE];
		
		ByteBuffer shortBuffer = ByteBuffer.allocate(2);
		ByteBuffer intBuffer = ByteBuffer.allocate(4);
		shortBuffer.order(ByteOrder.BIG_ENDIAN);
		intBuffer.order(ByteOrder.BIG_ENDIAN);
				
		shortBuffer.put(p.data[0]);
		shortBuffer.put(p.data[1]);
		shortBuffer.rewind();
		src_port = shortBuffer.getShort(); //SRC_PORT
		shortBuffer.rewind();
		shortBuffer.put(p.data[2]);
		shortBuffer.put(p.data[3]);
		shortBuffer.rewind();
		dest_port = shortBuffer.getShort(); //DEST_PORT
		shortBuffer.rewind();
		intBuffer.put(p.data[4]);
		intBuffer.put(p.data[5]);
		intBuffer.put(p.data[6]);
		intBuffer.put(p.data[7]);
		intBuffer.rewind();
		seqnum = intBuffer.getInt(); //SEQNUM
		intBuffer.rewind();
		intBuffer.put(p.data[8]);
		intBuffer.put(p.data[9]);
		intBuffer.put(p.data[10]);
		intBuffer.put(p.data[11]);
		intBuffer.rewind();
		acknum = intBuffer.getInt(); //ACKNUM
		intBuffer.rewind();
		//data_offset = (byte)((p.data[12] >> 4) & 0x0F);//DATA_OFFSET
		data_offset = p.data[12]; //DATA_OFFSET
		flags = p.data[13]; //FLAGS
		shortBuffer.put(p.data[14]);
		shortBuffer.put(p.data[15]);
		shortBuffer.rewind();
		window_size = shortBuffer.getShort(); //WINDOW_SIZE
		shortBuffer.rewind();
		shortBuffer.put(p.data[16]);
		shortBuffer.put(p.data[17]);
		shortBuffer.rewind();
		checksum = shortBuffer.getShort(); //CHECKSUM
		shortBuffer.rewind();
		shortBuffer.put(p.data[18]);
		shortBuffer.put(p.data[19]);
		shortBuffer.rewind();
		urg_pointer = shortBuffer.getShort(); //URG_POINTER
		shortBuffer.rewind();
		data = new byte[p.length - 20]; //DATA
		System.arraycopy(p.data, 20, data, 0, p.length - 20);
		
		return new TcpSegment(new TcpHeader(src_port, dest_port, seqnum, acknum, data_offset, flags, window_size, checksum, urg_pointer), data);
	}
	
	/**
	 * Checks whether the packet sends corresponds with what expected
	 *  Checks if addresses and ports corresponds with what is required
	 * 
	 * @param segment: TCPSegment containing the received Packets TCP info
	 * @param ph: Pseudoheader containing the received Packets IP info
	 * @return True if it was a correct packet | False if it was an incorrect packet
	 */
	public boolean correct_recvd_packet(TcpSegment segment, PseudoHeader ph) {
		if (tcb.dest_ipaddr.getAddress() == 0) {
			tcb.dest_ipaddr = ph.src_ipaddr;
		}
		if (tcb.src_port == 0) {
			tcb.src_port = segment.tcpHeader.dest_port;
		}
		if (tcb.dest_port == 0) {
			tcb.dest_port = segment.tcpHeader.src_port;
		}
		debugPrinter("COR_RCV_PACK:%d Packet details:\n" +
				"  TCB_dest_ipaddr: %d\tPH_dest_ipaddr: %d\n" +
				"  TCB_src_port: %d\tSGMT_dest_port: %d\n" +
				"  TCB_dest_port: %d\tSGMT_src_port: %d\n" +
				"  FLAGS: PSH=%b\tSYN=%b\tACK=%b\tFIN=%b\n" +
				"  TCB_src_seqnum: %d\tTCB_dest_seqnum: %d\n" +
				"  SGMT_seqnum: %d\tSGMT_acknum: %d\n",
				tcb.src_port,
				tcb.dest_ipaddr.getAddress(), ph.dest_ipaddr.getAddress(),
				tcb.src_port, segment.tcpHeader.dest_port,
				tcb.dest_port, segment.tcpHeader.src_port,
				(segment.tcpHeader.flags & PSH) == PSH, (segment.tcpHeader.flags & SYN) == SYN, (segment.tcpHeader.flags & ACK) == ACK, (segment.tcpHeader.flags & FIN) == FIN,
				tcb.src_seqnum, tcb.dest_seqnum,
				segment.tcpHeader.seqnum, segment.tcpHeader.acknum);//TODO remove
		if (tcb.dest_ipaddr.getAddress() == ph.src_ipaddr.getAddress() && tcb.src_port == segment.tcpHeader.dest_port && tcb.dest_port == segment.tcpHeader.src_port) {
			debugPrinter("COR_RCV_PACK:%d Packet was valid\n", tcb.src_port);//TODO remove
			return true;
		}
		debugPrinter("COR_RCV_PACK:%d Packet was Invalid\n", tcb.src_port);//TODO remove
		return false;
	}
	
	/**
	 * Receive a syn packet and based on the connection state
	 *  move to a follow up state
	 *   Inherently, receiving the syn is the second step of the 
	 *   3-way-handshake
	 * Only implement regular connect, not simultaneous connect.
	 * Follows from only accepting SYNACKs in SYN_SENT state and 
	 *  not accepting SYNs in SYN_SENT state
	 * If it is a SYN packet, set the acknowledgment and
	 *  destination sequence number according to the segment received
	 * 
	 * @param flags: byte variable for the flags of the packet received
	 */
	public int recv_syn(TcpSegment s) {
		debugPrinter("RECV_SYN:%d Checking Syn...first check flags\n", tcb.src_port);//TODO remove print
		//if (s.tcpHeader.flags != (PSH | SYN) && s.tcpHeader.flags != (PSH | SYN | ACK)) {
		if (s.tcpHeader.flags != SYN && s.tcpHeader.flags != (PSH | SYN) &&
				s.tcpHeader.flags != (SYN | ACK) && s.tcpHeader.flags != (PSH | SYN | ACK)) {
			debugPrinter("RECV_SYN:%d Flags were incorrect!\n" +
					"\tFlags:PSH=%b\tSYN=%b\tACK=%b\n",
					tcb.src_port,
					(s.tcpHeader.flags & PSH) == PSH, (s.tcpHeader.flags & SYN) == SYN, (s.tcpHeader.flags & ACK) == ACK);//TODO remove print
			return 0;
		}
		debugPrinter("RECV_SYN:%d Flags were correct, check state\n", tcb.src_port);//TODO remove print
		if (!tcb.state.equals(ConnectionState.LISTEN) && !tcb.state.equals(ConnectionState.SYN_SENT)) {
			debugPrinter("RECV_SYN:%d State was incorrect for receiving SYN\n" +
					"\ttcb.state: %s\n", tcb.src_port, tcb.state);//TODO remove print
			return 0;
		}
		debugPrinter("RECV_SYN:%d State and Flags were correct!\n" +
				"\tState: %s Flags:PSH=%b\tSYN=%b\tACK=%b\n",
				tcb.src_port, tcb.state, (s.tcpHeader.flags & PSH) == PSH, (s.tcpHeader.flags & SYN) == SYN, (s.tcpHeader.flags & ACK) == ACK);//TODO remove print
		
		//if (tcb.state.equals(ConnectionState.LISTEN) && s.tcpHeader.flags == (PSH | SYN)) {
		if (tcb.state.equals(ConnectionState.LISTEN) && (s.tcpHeader.flags == SYN || s.tcpHeader.flags == (PSH | SYN))) {
			/** 
			 * Accept side receives SYN from Client 
			 * Acknum to send should equal the seqnum received plus one because that is what they expect 
			 **/
			tcb.dest_seqnum = (s.tcpHeader.seqnum + 1) % Integer.MAX_VALUE;
			tcb.irseqnum = s.tcpHeader.seqnum;
			tcb.state = ConnectionState.SYN_RCVD;
			debugPrinter("RECV_SYN:%d Received SYN packet in Listen state\n" +
					"\tDestSeqnum: %d SegmentSeqNum: %d IRS: %d State: %s\n",
					tcb.src_port, tcb.dest_seqnum, s.tcpHeader.seqnum, tcb.irseqnum, tcb.state);//TODO remove
			return 1;
		}
		//else if (tcb.state.equals(ConnectionState.SYN_SENT) && s.tcpHeader.flags == (PSH | SYN | ACK)) {
		else if (tcb.state.equals(ConnectionState.SYN_SENT) && (s.tcpHeader.flags == (SYN | ACK) || s.tcpHeader.flags == (PSH | SYN | ACK))) {
			/** Only if the acknum is above or equal to the acknum we expect and below or equal to our seqnum, it's a valid SYNACK to be received in the SYN_SENT state */
			//if (tcb.expected_acknum <= s.tcpHeader.acknum && s.tcpHeader.acknum <= tcb.src_seqnum) {
			if (tcb.src_seqnum <= s.tcpHeader.acknum && s.tcpHeader.acknum <= tcb.expected_acknum) {
				/** 
				 * Connect side receives SYNACK from Server 
				 * Acknum to send should equal the seqnum received plus one because that is what they expect 
				 **/
				tcb.src_seqnum = s.tcpHeader.acknum;
				tcb.dest_seqnum = (s.tcpHeader.seqnum + 1) % Integer.MAX_VALUE;
				tcb.irseqnum = s.tcpHeader.seqnum;
				//tcb.expected_acknum = s.tcpHeader.acknum;
				tcb.state = ConnectionState.ESTABLISHED;
				debugPrinter("RECV_SYN:%d Received SYNACK packet in SYN_SENT state\n" +
						"\tDestSeqnum: %d SegmentSeqNum: %d IRS: %d ExpectedAcknum: %d SegmentAcknum: %d State: %s\n",
						tcb.src_port, tcb.dest_seqnum, s.tcpHeader.seqnum, tcb.irseqnum, tcb.expected_acknum, s.tcpHeader.acknum, tcb.state);//TODO remove
				return 1;
			}
			else {
				debugPrinter("RECV_SYN:%d ExpectedAcknum: %d SegmentAcknum: %d SourceSeqnum: %d\n", tcb.src_port, tcb.expected_acknum, s.tcpHeader.acknum, tcb.src_seqnum);//TODO remove
				System.err.println("Error: segment acknowledgment number incorrect");
				return 0;
			}
		}
		debugPrinter("RECV_SYN:%d Incorrent flags/state combination\n\tState: %s Flags: SYN=%b ACK=%b FIN=%b\n", tcb.src_port, tcb.state, (s.tcpHeader.flags & SYN) == SYN, (s.tcpHeader.flags & ACK) == ACK, (s.tcpHeader.flags & FIN) == FIN);//TODO remove
		System.err.println("Error: incorrect state/flags combination for receiving SYN");
		return 0;
	}
	
	/**
	 * Receive an ACK packet and based on the flags and current process
	 *  state, possibly change the state.
	 * Only instances were a sole ACK packet changes state,
	 *  is during the Handshake and Close steps.
	 * If it is an ACK packet, set the source sequence number 
	 *  according to the segment received
	 * 
	 * @param flags: byte variable for the flags of the packet received
	 */
	public int recv_ack(TcpSegment s) {
		debugPrinter("RECV_ACK:%d Checking ACK Flags...\n", tcb.src_port);//TODO Remove print
		//if (s.tcpHeader.flags != (PSH | ACK)) {
		if (s.tcpHeader.flags != ACK && s.tcpHeader.flags != (PSH | ACK)) {
			return 0;
		}
		debugPrinter("RECV_ACK:%d Checking State...\n", tcb.src_port);//TODO Remove print
		if (!tcb.state.equals(ConnectionState.SYN_RCVD) && !tcb.state.equals(ConnectionState.ESTABLISHED) &&
				!tcb.state.equals(ConnectionState.FIN_WAIT_1) && !tcb.state.equals(ConnectionState.CLOSE_WAIT) &&
				!tcb.state.equals(ConnectionState.CLOSING) && !tcb.state.equals(ConnectionState.LAST_ACK)) {
			debugPrinter("RECV_ACK:%d SHOULD NOT GET HERE! STATE: %s\n", tcb.src_port, tcb.state); //TODO Remove print
			return 0;
		}
		
		/** 
		 * HANDSHAKE
		 * Server receive ack in syn_rcvd state 
		 **/
		debugPrinter("RECV_ACK:%d GOT ACK! STATE: %s\n", tcb.src_port, tcb.state); //TODO Remove print
		if (tcb.state.equals(ConnectionState.SYN_RCVD)) {
			//if (tcb.expected_acknum <= s.tcpHeader.acknum && s.tcpHeader.acknum <= tcb.src_seqnum) {
			if (tcb.src_seqnum <= s.tcpHeader.acknum && s.tcpHeader.acknum <= tcb.expected_acknum) {
				debugPrinter("RECV_ACK:%d received ack in %s state, will move to ESTABLISHED\n" +
						"\tConnection Established!\n", tcb.src_port, tcb.state); //TODO Remove print
				debugPrinter("RECV_ACK:%d SERVER: CONNECTION ESTABLISHED!\n", tcb.src_port); //TODO Remove print
				tcb.state = ConnectionState.ESTABLISHED;
				//              return true;
			}
			else {
				debugPrinter("RECV_ACK:%d received incorrect ack in SYN_RCVD state\n" +
						"\texpected_acknum %d <= segment_acknum %d <= source_seqnum %d | was false",
						tcb.src_port, tcb.expected_acknum, s.tcpHeader.acknum, tcb.src_seqnum); //TODO Remove print
				return 0;
			}
		}
		//      else if (tcb.state.equals(ConnectionState.ESTABLISHED) || tcb.state.equals(ConnectionState.CLOSE_WAIT)) {
		//          if (tcb.expected_acknum < s.tcpHeader.acknum && s.tcpHeader.acknum <= tcb.src_seqnum) {
		//              debugPrinter("RECV_ACK:%d received ack in %s state, will move to ESTABLISHED\n" +
		//                      "\tConnection Established!\n", tcb.src_port, tcb.state); //TODO Remove print
		//              tcb.expected_acknum = s.tcpHeader.acknum;
		//              tcb.state = ConnectionState.ESTABLISHED;
		//              return true;
		//          }//TODO remove? Not sure if this is needed
		//          else {
		//              debugPrinter("RECV_ACK:%d received incorrect ack in %s state\n" +
		//                      "\texpected_acknum %d <= segment_acknum %d <= source_seqnum %d | was false", 
		//                      tcb.src_port, tcb.state, tcb.expected_acknum, s.tcpHeader.acknum, tcb.src_seqnum); //TODO Remove print
		//          }
		//      }
		/**
		 * CLOSE 
		 * 1. Client receive ack in fin_wait_one state
		 * 2. Server receive ack in last_ack state 
		 **/
		else if (tcb.state.equals(ConnectionState.FIN_WAIT_1)) {
			//if (tcb.expected_acknum <= s.tcpHeader.acknum && s.tcpHeader.acknum <= tcb.src_seqnum) {
			debugPrinter("RECV_ACK:%d received ack in FIN_WAIT_1 state, will move to FIN_WAIT_2\n", tcb.src_port); //TODO Remove print
			tcb.state = ConnectionState.FIN_WAIT_2;
			//              return true;
			//          }
			//          else {
			//              debugPrinter("RECV_ACK:%d received incorrect ack in FIN_WAIT_1 state\n" +
			//                      "\texpected_acknum %d <= segment_acknum %d <= source_seqnum %d | was false", 
			//                      tcb.src_port, tcb.expected_acknum, s.tcpHeader.acknum, tcb.src_seqnum); //TODO Remove print
			//          }
		}
		else if (tcb.state.equals(ConnectionState.LAST_ACK)) {
			//          if (tcb.expected_acknum <= s.tcpHeader.acknum && s.tcpHeader.acknum <= tcb.src_seqnum) {
			debugPrinter("RECV_ACK:%d received ack in LAST_ACK state, will move to CLOSED\n", tcb.src_port); //TODO Remove print
			tcb.state = ConnectionState.CLOSED;
			//              return true;
			//          }
			//          else {
			//              debugPrinter("RECV_ACK:%d received incorrect ack in LAST_ACK state\n" +
			//                      "\texpected_acknum %d <= segment_acknum %d <= source_seqnum %d | was false", 
			//                      tcb.src_port, tcb.expected_acknum, s.tcpHeader.acknum, tcb.src_seqnum); //TODO Remove print
			//          }
		}
		else if (tcb.state.equals(ConnectionState.CLOSING)) {
			//          if (tcb.expected_acknum <= s.tcpHeader.acknum && s.tcpHeader.acknum <= tcb.src_seqnum) {
			debugPrinter("RECV_ACK:%d received ack in CLOSING state, will move to TIME_WAIT\n", tcb.src_port); //TODO Remove print
			tcb.state = ConnectionState.TIME_WAIT;
			//              return true;
			//          }
			//          else {
			//              debugPrinter("RECV_ACK:%d received incorrect ack in CLOSING state\n" +
			//                      "\texpected_acknum %d <= segment_acknum %d <= source_seqnum %d | was false", 
			//                      tcb.src_port, tcb.expected_acknum, s.tcpHeader.acknum, tcb.src_seqnum); //TODO Remove print
			//          }
		}
		/**
		 * Set the expected acknowledgment number to the segment 
		 *  acknowledgment number received, since that will be the 
		 *  the acknowledgment number we at least expect to get
		 */
		tcb.src_seqnum = s.tcpHeader.acknum;//TODO move our sequence number finally, since they acked our packet. Only then can we move on
		return 1;
	}
	
	/**
	 * If it is a data packet, set the acknowledgment and
	 *  destination sequence number according to the segment received
	 * 
	 * @param flags: byte variable for the flags of the packet received
	 */
	public int recv_data(TcpSegment s) {
		debugPrinter("RECV_DATA:%d Checking if data is filled\n", tcb.src_port);//TODO remove print
		//		if (s.tcpHeader.flags != PSH) {
		//			return false;
		//		}
		if (s.data.length <= 0) {
			return 0;
		}
		debugPrinter("RECV_DATA:%d Checking Data possibility | State...\n", tcb.src_port);//TODO remove print
		if (!tcb.state.equals(ConnectionState.ESTABLISHED) && !tcb.state.equals(ConnectionState.FIN_WAIT_1) &&
				!tcb.state.equals(ConnectionState.FIN_WAIT_2)) {
			return 0;
		}
		debugPrinter("RECV_DATA:%d Received a data packet of length (arrayLength)%d\n", tcb.src_port, s.data.length);//TODO remove print
		/** Acknum to send should equal the seqnum received, plus the data size */
		tcb.data = s.data;
		tcb.dest_seqnum = (s.tcpHeader.seqnum + s.data.length) % Integer.MAX_VALUE;
		return 1;
	}
	
	/**
	 * Receive a FIN packet and based on whether the flags are set 
	 *  and if the client/server is in the correct state to call a close, 
	 *  proceed to a follow up state based on the flag from the packet and
	 *  the current state 
	 * If it is a FIN packet, set the acknowledgment and
	 *  destination sequence number according to the segment received
	 * 
	 * @param flags: byte variable for the flags of the packet received
	 */
	public int recv_fin(TcpSegment s) {
		debugPrinter("RECV_FIN:%d Checking Flags...\n", tcb.src_port);
		if (s.tcpHeader.flags != FIN && s.tcpHeader.flags != (PSH | FIN) && s.tcpHeader.flags != (FIN | ACK) && s.tcpHeader.flags != (PSH | FIN | ACK)) {
			return 0;
		}
		debugPrinter("RECV_FIN:%d Checking State...\n", tcb.src_port);
		if (!tcb.state.equals(ConnectionState.ESTABLISHED) && !tcb.state.equals(ConnectionState.FIN_WAIT_1) && !tcb.state.equals(ConnectionState.FIN_WAIT_2)) {
			return 0;
		}
		debugPrinter("RECV_FIN:%d Received a FIN packet | State: %s\n", tcb.src_port, tcb.state);
		
		if (s.tcpHeader.flags == FIN || s.tcpHeader.flags == (PSH | FIN) || s.tcpHeader.flags == (FIN | ACK) || s.tcpHeader.flags == (PSH | FIN | ACK)) {
			if (tcb.state.equals(ConnectionState.SYN_RCVD) || tcb.state.equals(ConnectionState.ESTABLISHED)) {
				/** Server receives FIN from Client */
				//tcb.dest_seqnum = (s.tcpHeader.seqnum + 1) % Integer.MAX_VALUE;
				tcb.state = ConnectionState.CLOSE_WAIT;
			}
			if (tcb.state.equals(ConnectionState.FIN_WAIT_1)) {
				/** Server receives FIN from Client */
				//increment src_seqnum here, since normally src_seqnum would only be incremented when receiving an ACK
				//BUT, since an FIN was received on the FIN, the src_seqnum will not be incremented in recv_ack
				tcb.src_seqnum = (tcb.src_seqnum + 1) % Integer.MAX_VALUE;
				//tcb.dest_seqnum = (s.tcpHeader.seqnum + 1) % Integer.MAX_VALUE;
				tcb.state = ConnectionState.CLOSING;//TODO should maybe send a fin instead of an ack in this state, so both sides will move to state CLOSING
			}
			if (tcb.state.equals(ConnectionState.FIN_WAIT_2)) {
				/** Clients receives FIN from Server */
				//tcb.dest_seqnum = (s.tcpHeader.seqnum + 1) % Integer.MAX_VALUE;
				tcb.state = ConnectionState.TIME_WAIT;
			}
		}
		//		else if (s.tcpHeader.flags == (PSH | FIN | ACK) && tcb.state.equals(ConnectionState.FIN_WAIT_1)) {
		//		else if ((s.tcpHeader.flags == (FIN | ACK) || s.tcpHeader.flags == (PSH | FIN | ACK)) && tcb.state.equals(ConnectionState.FIN_WAIT_1)) {
		//			/** Client receives FINACK from Server */
		//			debugPrinter("RECV_FIN:%d Received FINACK packet\n" +
		//					"\tSegmentSeqnum: %d SegmentAcknum: %d\n" +
		//					"\tTCBSeqnum: %d TCBExpectedAcknum: %d\n",
		//					tcb.src_port, s.tcpHeader.seqnum, s.tcpHeader.acknum, tcb.src_seqnum, tcb.expected_acknum);
		//			tcb.state = ConnectionState.TIME_WAIT;
		//			tcb.src_seqnum = (tcb.src_seqnum + 1) % Integer.MAX_VALUE;
		//			tcb.dest_seqnum = (s.tcpHeader.seqnum + 1) % Integer.MAX_VALUE;
		//			debugPrinter("RECV_FIN:%d Since we received a FINACK, we should increment src_seqnum with the received acknum\n" +
		//					"\tTCBSeqnum: %d\n", tcb.src_port, tcb.src_seqnum);
		//		}
		/** 
		 * Acknum to send should equal the seqnum received, plus the packet size
		 * Additionally 
		 * send ack here, since an ack should be send in any case if this point is reached 
		 */
		tcb.dest_seqnum = (s.tcpHeader.seqnum + 1) % Integer.MAX_VALUE;
		send_ack();
		return 1;
	}
	
	/**
	 * Check whether the source sequence number equals
	 *  the expected acknowledgment number.
	 * Only if these are equal, we received a correct 
	 *  acknowledgment to our previously send packet.
	 *  
	 * @return true if the source sequence number
	 *  equals the expected acknowledgment number
	 */
	public boolean received_all_acks() {
		return tcb.src_seqnum == tcb.expected_acknum;
	}
	
	/**
	 * Method checking whether the 'DEBUG' flag is set
	 * If true, write the String object passed as a
	 *  parameter
	 *  
	 * @param s: Debug String object to print
	 * @param args: Object Array of arguments used for the print
	 */
	public void debugPrinter(String s, Object... args) {
		if (DEBUG) {
			debugPrinter(s, args);
		}
	}
}
